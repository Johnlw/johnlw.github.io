<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="John What">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="John What">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="John What">






  <link rel="canonical" href="http://yoursite.com/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>John What</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">John What</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/28/单例模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John What">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/02/28/单例模式/" class="post-title-link" itemprop="url">单例模式</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-02-28 16:03:51" itemprop="dateCreated datePublished" datetime="2018-02-28T16:03:51+08:00">2018-02-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 20:25:05" itemprop="dateModified" datetime="2019-01-24T20:25:05+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="单例模式定义"><a href="#单例模式定义" class="headerlink" title="单例模式定义"></a>单例模式定义</h3><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p>
<h3 id="单例模式优缺点"><a href="#单例模式优缺点" class="headerlink" title="单例模式优缺点"></a>单例模式优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>在内存中只有一个实例，节约内存，减少性能开销。当一个对象的产生需要占用较多资源时（如文件、读取配置文件等），采用单例模式可有效节约资源。</li>
<li>单例对象可以作为全局访问点，优化和共享全局资源访问。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>单例模式要求自行实例化，因此单例模式一般没有接口，拓展性不好。<h3 id="单例模式使用场景"><a href="#单例模式使用场景" class="headerlink" title="单例模式使用场景"></a>单例模式使用场景</h3></li>
<li>要求生成唯一序列号的场景</li>
<li>在整个项目中需要一个共享访问点或共享资源</li>
<li>创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源</li>
<li>需要定义大量的静态变量和静态方法的场景</li>
</ul>
<h3 id="单例模式代码形式"><a href="#单例模式代码形式" class="headerlink" title="单例模式代码形式"></a>单例模式代码形式</h3><h4 id="饿汉形式"><a href="#饿汉形式" class="headerlink" title="饿汉形式"></a>饿汉形式</h4><pre><code>public class Singleton{
      private static Singleton instance = new Singleton();//在类加载时即进行创建
      private Singleton(){}
      public static Singleton newInstance(){
            return instance;
      }
}
</code></pre><p>饿汉形式中该对象在类加载的时候就完成了对象的创建，不存在线程安全问题。当对象占用内存小而且初始化后很快就会被用到时，饿汉形式很适用；但是如果这个对象并不急着用或者根本没有用到，该对象还是会被创建，如果该对象占用的内存空间较大，则造成了系统资源的浪费。</p>
<h4 id="懒汉形式"><a href="#懒汉形式" class="headerlink" title="懒汉形式"></a>懒汉形式</h4><pre><code>public class Singleton{
      private static Singleton instance = null;
      private Singleton(){}
      public static Singleton newInstance(){
             if(instance == null){
                   instance =  new Singleton();
             }
             return instance;
      }
}
</code></pre><p>懒汉形式中该对象时在需要的时候才去创建，即按需使用，在单例使用次数少、占用资源多的场景下比较适用。但是懒汉形式并不是线程安全的，当有多个线程同时调用newInstance方法时，可能会创建多个实例。</p>
<h4 id="线程安全的懒汉形式"><a href="#线程安全的懒汉形式" class="headerlink" title="线程安全的懒汉形式"></a>线程安全的懒汉形式</h4><pre><code>public class Singleton{
      private static Singleton instance = null;
      private Singleton(){}
      public static synchronized Singleton newInstance(){//使用synchronized关键字同步
             if(instance == null){
                   instance =  new Singleton();
             }
             return instance;
      }
}
</code></pre><p>这种形式下，线程每次调用newInstance方法都会先获取对象锁，然后再执行方法体，在高并发情况下，对象锁有可能升级为重量级锁，带来一定的性能问题。</p>
<h4 id="一种看起来可行的改进方式–双重检查锁定形式"><a href="#一种看起来可行的改进方式–双重检查锁定形式" class="headerlink" title="一种看起来可行的改进方式–双重检查锁定形式"></a>一种看起来可行的改进方式–双重检查锁定形式</h4><p>既然存在性能问题，我们将代码稍加改进：</p>
<pre><code>public class Singleton{
      private static Singleton instance = null;
      private Singleton(){}
      public static Singleton newInstance(){
             if(instance == null){
                  synchronized(Singleton.class){
                        if(instance == null){
                            instance =  new Singleton();
                        }                  
                  }                                 
             }
             return instance;
       }
}
</code></pre><p>在这种形式的代码下，只要对象被线程安全的创建成功，将不会在存在性能问题。然而既然是“看起来可行的”办法，那么一定有什么隐患。</p>
<h4 id="可靠的改进方式–volatile"><a href="#可靠的改进方式–volatile" class="headerlink" title="可靠的改进方式–volatile"></a>可靠的改进方式–volatile</h4><p>上面的双重检查锁定形式不可靠的地方在于它并不能保证线程安全，根本原因在于<code>instance = new Singleton();</code> 这一行代码可以分为如下三行伪代码：</p>
<pre><code>memory = allocate();//1.分配内存
initInstance(memory);//2.初始化
instance = memory;3.设置引用指向内存地址
</code></pre><p>我们知道在java代码的各级编译过程中都存在执行重排序的情况，如果上述代码中2和3被重排序，3先于2执行，并不违反单线程as-if-serial语义和多线程happens-before语义，再如果在2执行之前发生线程切换，另外一个线程在判断instance变量是否为Null时将返回false，并返回Instance，然而此时instance对应的内存区域并没有被初始化为Singleton对象。</p>
<p>那么我们应该如何处理这种情况呢？很简单，禁止<code>instance = new Singleton();</code>这行代码指令重排序，为此我们给instance变量引入happens-before语义限制—-就是用<code>volatile</code>关键字修饰instance变量。可靠的改进方式：</p>
<pre><code>public class Singleton{
      private static volatile Singleton instance = null;
      private Singleton(){}
      public static Singleton newInstance(){
             if(instance == null){
                  synchronized(Singleton.class){
                        if(instance == null){
                            instance =  new Singleton();
                        }                  
                  }                                 
             }
             return instance;
       }
}
</code></pre><h4 id="静态内部类形式"><a href="#静态内部类形式" class="headerlink" title="静态内部类形式"></a>静态内部类形式</h4><pre><code>public class Singleton{
    private static class SingletonHolder{
        public static Singleton instance = new Singleton();
    }
    public static Singleton newInstance(){
        return SingletonHolder.instance;
    }
}
</code></pre><p>在这种形式中，巧妙地利用的jvm的类加载机制，实现了线程安全的懒汉式实例化。<br>当线程调用newInstance方法时，会触发静态内部类SingletonHolder的加载和初始化，这里不存在线程安全问题；同时当没有线程调用newInstance方法时，静态内部类将不会被加载。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>由上面的分析可知，<strong>静态内部类形式</strong>和<strong>volatile关键字改进的双重检查锁定形式</strong>最能称得上是单例模式的最佳实践。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/24/Java并发机制（4）--AQS、ReentrantLock、ReentrantReadWriteLock源码分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John What">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/11/24/Java并发机制（4）--AQS、ReentrantLock、ReentrantReadWriteLock源码分析/" class="post-title-link" itemprop="url">Java并发机制（4）--AQS、ReentrantLock、ReentrantReadWriteLock源码分析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-11-24 16:20:31" itemprop="dateCreated datePublished" datetime="2017-11-24T16:20:31+08:00">2017-11-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 20:13:28" itemprop="dateModified" datetime="2019-01-24T20:13:28+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>锁是用来控制多个线程访问共享资源的工具，Java中有两种锁，一种是jvm层面的synchronized关键字，一种是JUC的Lock接口的实现类。<br>Lock接口对比synchronized关键字需要显示的获取/释放锁，虽然丧失了一定的便捷性，但是提供了synchronized关键字所不具备的获取/释放锁的灵活性、可中断获取锁、超时获取锁、非阻塞获取锁（trylock）、以及多个条件变量。</p>
<p>队列同步器（AQS），是用来构建锁和其他同步组件的基础框架，它提供了自动管理同步状态、线程的阻塞/唤醒、排队、条件变量以及监控五个方面的通用结构。AQS的设计模式基于模板方法模式，主要使用方式为继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，相当于子类同步器将同步的管理委托给AQS。</p>
<p>本文将沿着锁的获取到释放这个过程深入到AQS的源码实现。</p>
<h1 id="进一步认识锁"><a href="#进一步认识锁" class="headerlink" title="进一步认识锁"></a>进一步认识锁</h1><ol>
<li>公平/非公平。<br>锁按照获取策略可以分为公平锁和非公平锁。公平锁即要获取锁的线程都要按先来后到的顺序排队。非公平锁即在条件允许的情况下，谁竞争成功则谁获取到锁，获取失败的线程排队。</li>
<li>共享/排他<br>按照对于共享资源的访问模式，锁可以分为共享锁和排他锁。当多个线程都是读操作时，对共享资源内容不会修改，可以安全的并发访问，使用共享锁可以提高系统吞吐量。当多个线程中含有写操作时，会修改共享资源的内容，必须要采用排他模式保证共享资源的线程安全。</li>
<li>可重入锁<br>也叫递归锁。已经获取锁的线程在执行过程中可以不用竞争直接继续获取锁，只需在同步状态中记录索取的次数即可。可重入锁提高效率的同时，也可以有效避免死锁的发生。</li>
</ol>
<p>由之前的文章我们可知synchronized关键字提供的是非公平的、排他、可重入的锁。由AQS框架支撑的可重入锁ReentrantLock可以选择公平性，ReentrantReadWriteLock可以选择公平性、共享性。这里就可以体现出Lock接口下的锁的灵活之处。</p>
<p>这里有个线程饥饿的问题，就是当获取策略为非公平，共享锁和排他锁共存的情况，有可能造成排他锁线程长期饥饿状态得不到运行的情况。需要在排队时做出一定的限制，保证排他锁也有机会获取锁。</p>
<hr>
<h1 id="初识AQS"><a href="#初识AQS" class="headerlink" title="初识AQS"></a>初识AQS</h1><p>AQS主要提供了同步状态的管理、线程的阻塞/唤醒、排队、条件变量、监控五个方面的功能。</p>
<h3 id="同步状态的管理"><a href="#同步状态的管理" class="headerlink" title="同步状态的管理"></a>同步状态的管理</h3><p>AQS有一个volatile修饰的int变量state用于表示同步状态，在前面的文章我们讲解过volatile关键字的作用。同时提供了三个子类可访问的getState()，setState(int newState)，compareAndSetState(int expect, int update)的方法来访问和修改同步状态。<br>线程获取同步锁的策略由抽象方法tryAcquire(int arg)，tryRelease(int arg)，tryAcquireShared(int arg)，tryReleaseShared(int arg)描述，交由子类自己实现。这里AQS将操作和策略解耦，AQS本身并不关心子类怎么定义获取，怎么定义获取成功与失败，AQS关心的是当线程获取失败后如何处理（阻塞/唤醒、排队等），将获取策略解耦交给子类可以借以实现更复杂更灵活的同步方案（如排他模式下的公平锁和非公平锁ReentrantLock，共享模式下的ReentrantReadWriteLock等。）</p>
<h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><p>AQS内部维护了一个的带头尾引用的双链表用以构成一个FIFO的类CLH队列，队列中的节点类型由内部类Node表示。Node节点含有等待线程的引用、Node是共享/排他型节点、Node的状态、前后Node的引用等信息。head节点中的线程为当前队列中获取到锁的线程。<br>当线程竞争共享资源失败后，AQS将用该线程构建Node，并将其入队。</p>
<h3 id="阻塞与唤醒"><a href="#阻塞与唤醒" class="headerlink" title="阻塞与唤醒"></a>阻塞与唤醒</h3><p>线程在获取资源失败后在AQS中入队，该线程即将阻塞以释放CPU，这里Node节点的状态信息将发挥关键作用。<br>|waitStatus 节点状态|意义|<br>|-|-|<br>|CANCELLED|值为1，在线程在排队过程中出现了超时或者中断时，该线程将被取消，此时该节点状态将被置为1|<br>|SIGNAL|值为-1，由后继节点设置，当后继节点将当前节点状态设置为-1后，后继节点进入阻塞态；当前节点如果释放了资源或者被取消，将会通知后继节点（唤醒它）|<br>|CONDITION|值为-2，当节点在条件变量上等待时，节点的状态为CONDITION|<br>|PROPAGATE|值为-3，用于共享模式，表示下一次共享式同步状态将会无条件地被传播下去|<br>|INITIAL|值为0，初始状态|</p>
<p>线程入队后，检查前驱节点是否被取消，如果被取消则向前进直到找到未取消的前驱节点，将该前驱节点的状态设置为SIGNAL，然后进入阻塞态。<br>head节点为队列中当前占用资源的线程，该线程释放资源时，将唤醒后继节点竞争锁。<br>这类似等待/通知模式，这种方式避免了自旋主动查询浪费CPU时间。</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量常与互斥量一起使用，在条件变量上的等待需要先获取互斥量。AQS的等待/通知机制由内部类ConditionObject支持。ConditionObject实现了Condition接口，内部维护了一个带有首尾引用的FIFO单链表。节点类型依然为Node。<br>当有线程在某个ConditionObject上等待（调用Condition.await()）时，那么该线程首先将释放锁，然后构造新的Node类型节点入队并进入阻塞状态。<br>调用ConditionObject对象上的signal()方法，先将首节点移至同步等待队列队尾，然后唤醒该线程，进而加入到同步状态的竞争中。</p>
<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>AQS提供了一些用于监控当前同步队列和条件队列的方法。如getQueueLength()，getQueuedThreads()，getExclusiveQueuedThreads()，getSharedQueuedThreads()，getWaitQueueLength(ConditionObject condition)等，便于对同步器的竞争状态有个估计（AQS中的队列一直在变化，监测方法只能返回一个估计值）。</p>
<hr>
<p>锁有两个基本的操作，一个是锁的获取，一个是锁的释放。</p>
<p>AQS支持不可中断、可中断、超时三种类型的获取锁，后两者均基于不可中断的获取模式；同时AQS还支持共享锁和排他锁，这里我们先以不可中断方式、排他模式进行分析。</p>
<h1 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h1><h3 id="获取过程"><a href="#获取过程" class="headerlink" title="获取过程"></a>获取过程</h3><p>AQS的acquire方法：</p>
<pre><code>public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre><p>代码逻辑：先尝试获取（此方法由子类自己定义），如果尝试失败了，则新增节点（addWaiter），再进行排队（acquireQueued）。新增节点是先将当前线程构建新节点，然后CAS设置tail节点入队。重点在入队之后的acquireQueued方法：</p>
<pre><code>final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
        //进入队列后进入循环
            final Node p = node.predecessor();
            //当前驱节点为head节点时，当前节点具有竞争资格，如果竞争成功，则将当前节点设置为头结点，并从循环中退出。也就是说，队列中只有头结点是占有锁的。
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            //如果前驱节点不是head节点，或者竞争失败，看下面的shouldParkAfterFailedAcquire(p, node)方法
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    //如果前驱节点状态是SIGNAL，则表示前驱节点在释放资源时会通知自己，这时候返回true，由parkAndCheckInterrupt()方法阻塞线程。
    if (ws == Node.SIGNAL)
        /*
         * This node has already set status asking a release
         * to signal it, so it can safely park.
         */
        return true;
        //如果前驱节点状态大于0，只可能是节点已经被取消，则不断前进直到找到未取消的节点
    if (ws &gt; 0) {
        /*
         * Predecessor was cancelled. Skip over predecessors and
         * indicate retry.
         */
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else {
    //除去上面两种状态，现在只可能是0或者PROPAGATE状态了，因为shouldParkAfterFailedAcquire是获取失败或者没资格获取后调用的方法，我们需要将前驱节点的状态CAS设置为SIGNAL，以便当资源可用时通知自己去竞争。
        /*
         * waitStatus must be 0 or PROPAGATE.  Indicate that we
         * need a signal, but don&apos;t park yet.  Caller will need to
         * retry to make sure it cannot acquire before parking.
         */
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
</code></pre><p>这里我们可以看到每个新节点入队后，都会在前驱节点的SIGNAL状态上阻塞。另外在当自己有了竞争资格但是竞争失败的情况下，如果头结点状态不为SIGNAL，自己可能还有几次的循环请求的机会。</p>
<p>至此，不可中断、排他模式的锁获取过程就完成了，获取失败的节点在队列中阻塞，等待前驱节点的唤醒。</p>
<h3 id="释放过程"><a href="#释放过程" class="headerlink" title="释放过程"></a>释放过程</h3><p>继续看排他模式，源码如下：</p>
<pre><code>public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
</code></pre><p>代码逻辑：如果尝试释放锁成功，则调用unparkSuccessor方法唤醒头结点的后继节点。</p>
<pre><code>private void unparkSuccessor(Node node) {
    /*
     * If status is negative (i.e., possibly needing signal) try
     * to clear in anticipation of signalling.  It is OK if this
     * fails or if status is changed by waiting thread.
     */
    int ws = node.waitStatus;
    if (ws &lt; 0)
        compareAndSetWaitStatus(node, ws, 0);

    /*
     * Thread to unpark is held in successor, which is normally
     * just the next node.  But if cancelled or apparently null,
     * traverse backwards from tail to find the actual
     * non-cancelled successor.
     */
    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);
}
</code></pre><h3 id="排它锁实例ReentrantLock"><a href="#排它锁实例ReentrantLock" class="headerlink" title="排它锁实例ReentrantLock"></a>排它锁实例ReentrantLock</h3><p>ReentrantLock实现了Lock接口，提供公平与非公平两种模式，分别由静态内部类NonfairSync和FairSync支撑，这两个静态内部类都是抽象内部类Sync的子类，而Sync继承自AQS。</p>
<h4 id="公平模式"><a href="#公平模式" class="headerlink" title="公平模式"></a>公平模式</h4><p>可以看到公平模式的lock方法直接调用了AQS acquire()方法：</p>
<pre><code>final void lock() {
        acquire(1);
    }
</code></pre><p>公平模式的tryAcquire方法：</p>
<pre><code>protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
        //在CAS设置同步状态之前，加了一个hasQueuedPredecessors()，如果已经有前驱在排队了，那么获取失败，也就是说对于每个线程都是严格排队的，即所谓公平。
            if (!hasQueuedPredecessors() &amp;&amp;
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &lt; 0)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);
            return true;
        }
        return false;
    }
</code></pre><h4 id="非公平模式"><a href="#非公平模式" class="headerlink" title="非公平模式"></a>非公平模式</h4><p>直接上代码：</p>
<pre><code>final void lock() {
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            acquire(1);
    }
</code></pre><p>不管是否有前驱节点在排队，先直接以0为预期值CAS设置同步状态，如果成功了就设置当前线程为获取锁的线程。如果失败则调用AQS acquire获取锁逻辑（上面讲过，先尝试，不成功再排队）。并不考虑当前是否已经有前驱节点在排队，即所谓非公平。</p>
<p>我们再看一下NonfairSync所对应的tryAcquire方法：</p>
<pre><code>final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
       //如果当前线程和当前拥有锁的线程是同一个线程，允许重入，只需要将同步状态+1表示重入次数即可。
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &lt; 0) // overflow
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);
            return true;
        }
        return false;
    }
</code></pre><p>非公平模式相较于公平模式少了一些排队的开销，在实际应用中有更大的吞吐量。</p>
<p>公平模式和非公平模式的释放过程是一致的，都是直接调用AQS release(int arg)方法，我们来看其对应的tryRelease()方法：</p>
<pre><code>protected final boolean tryRelease(int releases) {
        //获得一次锁，同步状态+1，释放时每释放一次同步状态-1，直到状态为0，可重入锁全部释放完毕。
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }
</code></pre><p>如前文所述，AQS还支持共享模式获取锁。</p>
<h1 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h1><h3 id="释放过程-1"><a href="#释放过程-1" class="headerlink" title="释放过程"></a>释放过程</h3><p>因为共享锁的获取过程中调用了释放过程，我们这里先说明共享锁的释放过程。AQS中releaseShared()方法：</p>
<pre><code>public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}

private void doReleaseShared() {
    /*
     * Ensure that a release propagates, even if there are other
     * in-progress acquires/releases.  This proceeds in the usual
     * way of trying to unparkSuccessor of head if it needs
     * signal. But if it does not, status is set to PROPAGATE to
     * ensure that upon release, propagation continues.
     * Additionally, we must loop in case a new node is added
     * while we are doing this. Also, unlike other uses of
     * unparkSuccessor, we need to know if CAS to reset status
     * fails, if so rechecking.
     */
    for (;;) {
        Node h = head;
        if (h != null &amp;&amp; h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
            //暂时不清楚这里两个循环CAS的意义具体是啥
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                    //在释放共享锁的同时唤醒后继节点
                unparkSuccessor(h);
            }
            else if (ws == 0 &amp;&amp;
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        //这里也不是很清楚，如果一个共享节点的后续节点是排他节点，那么共享节点setHeadAndPropagate时，并不会唤醒后继节点。如果共享节点的后继是共享型的，那么该后继改变了head节点意味着它已经获取了锁，这里如果重新循环，那么不管该后继的后继是共享型的还是排他型的，该后继都会唤醒它的后继？
        if (h == head)                   // loop if head changed
            break;
    }
}
</code></pre><h3 id="获取过程-1"><a href="#获取过程-1" class="headerlink" title="获取过程"></a>获取过程</h3><p>AQS的acquireShared方法：</p>
<pre><code>public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}
</code></pre><p>先尝试获取共享锁，失败后进入doAcquireShared()方法，其中tryAcquireShared()方法由子类实现。</p>
<pre><code>private void doAcquireShared(int arg) {
//添加新共享类型的节点
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                //tryAcquireShared返回int整数，负数表示失败，0表示成功但是后面不能再继续有线程获取共享锁了，正数表示成功并且后面的线程可以继续获取共享锁。
                if (r &gt;= 0) {
                //如果获取成功，将当前节点设置为头节点并传播
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            //获取失败则排队阻塞
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // Record old head for check below
    setHead(node);
    /*
     * Try to signal next queued node if:
     *   Propagation was indicated by caller,
     *     or was recorded (as h.waitStatus) by a previous operation
     *     (note: this uses sign-check of waitStatus because
     *      PROPAGATE status may transition to SIGNAL.)
     * and
     *   The next node is waiting in shared mode,
     *     or we don&apos;t know, because it appears null
     *
     * The conservatism in both of these checks may cause
     * unnecessary wake-ups, but only when there are multiple
     * racing acquires/releases, so most need signals now or soon
     * anyway.
     */
     //注意到在获取共享锁的时候，设置当前节点为头结点，如果允许其他线程继续获取共享锁（tryAcquireShared返回大于0），且下一个等待线程是共享类型的节点，将进入doReleaseShared()方法
    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();
    }
}
</code></pre><p>共享锁在获取成功后，如果条件允许且下一个等待线程是共享类型的节点，那么该线程会唤醒它。与排他锁相比，共享锁不仅在释放锁时唤醒后继节点，在获取锁成功后亦会唤醒后继的共享节点。</p>
<h1 id="共享锁-排他锁示例ReentrantReadWriteLock"><a href="#共享锁-排他锁示例ReentrantReadWriteLock" class="headerlink" title="共享锁/排他锁示例ReentrantReadWriteLock"></a>共享锁/排他锁示例ReentrantReadWriteLock</h1><p>ReentrantReadWriteLock实现了ReadWriteLock接口，同时提供读锁和写锁。它共有5个内部类：ReadLock，WriteLock，Sync，FairSync，NonfairSync。<br>Sync继承自AQS，不像ReentrantLock中的Sync，只实现了AQS的排他锁的获取与释放。这里一并实现了AQS的排它锁获取与释放（tryAcquire/tryRelease）和共享锁的获取和释放（tryAcquireShared/tryReleaseShared），AQS的灵活性可见一斑。<br>FairSync与NonfairSync继承Sync提供了公平性与非公平性的选择。<br>ReadLock与WriteLock均实现了Lock接口，两者使用同一个已确定公平性策略的Sync对象作为同步器来管理读锁和写锁的并发控制。<br>ReentrantReadWriteLock相比于ReentrantLock，多了共享锁，在读多于写的场景下，前者比后者能提供更大的吞吐量。</p>
<p>ReentrantReadWriteLock实现基于：并发读共享资源不会有线程安全问题，而只要操作中含有并发写就会带来线程安全问题，必须正确同步。并发读由共享锁-读锁支持，并发写由排他锁-写锁支持。</p>
<p>来看一下ReentrantReadWriteLock中的Sync是如何做到的吧。</p>
<h2 id="同步状态的表示"><a href="#同步状态的表示" class="headerlink" title="同步状态的表示"></a>同步状态的表示</h2><p>由于AQS只有一个int型state变量表示同步状态，而读写锁需要同时表示读锁和写锁的状态，Sync中将该state变量一拆为二，高16位用于表示读锁状态，低16位用于表示写锁状态。</p>
<pre><code>static int sharedCount(int c)    { return c &gt;&gt;&gt; SHARED_SHIFT; }
static int exclusiveCount(int c) { return c &amp; EXCLUSIVE_MASK; }
</code></pre><p>两个方法通过位运算在同一个int变量上维护了读锁和写锁的状态。<br>对于读锁，sharedCount返回值反映了当前获取读锁的次数，对于读线程的重入计数，由ThreadLocal的子类ThreadLocalHoldCounter变量readHolds支撑，该变量为每个读线程记录了重入数目，原理可以阅读ThreadLocal源码。<br>对于写锁，exclusiveCount返回值反应了当前写锁的获取状态和重入次数。</p>
<h2 id="公平性策略"><a href="#公平性策略" class="headerlink" title="公平性策略"></a>公平性策略</h2><pre><code>abstract boolean readerShouldBlock();
abstract boolean writerShouldBlock();
</code></pre><p>Sync定义了两个抽象方法，用来控制并发线程入队的公平性。<br>非公平：</p>
<pre><code>static final class NonfairSync extends Sync {
    private static final long serialVersionUID = -8159625535654395037L;
    //非公平策略下，写线程总是可以直接竞争锁
    final boolean writerShouldBlock() {
        return false; // writers can always barge
    }
    //读线程在同步等待队列的第一个节点不为排他型节点时也可以直接竞争锁，但是如果第一个节点为排他型节点，该读线程将阻塞，这样可以防止在排队的写线程长期饥饿，不公平中为写线程争取了公平。
    final boolean readerShouldBlock() {
        /* As a heuristic to avoid indefinite writer starvation,
         * block if the thread that momentarily appears to be head
         * of queue, if one exists, is a waiting writer.  This is
         * only a probabilistic effect since a new reader will not
         * block if there is a waiting writer behind other enabled
         * readers that have not yet drained from the queue.
         */
        return apparentlyFirstQueuedIsExclusive();
    }
}
//检查同步等待队列中的第一个节点是否是排他型，如果是排他型则返回true。
final boolean apparentlyFirstQueuedIsExclusive() {
    Node h, s;
    return (h = head) != null &amp;&amp;
        (s = h.next)  != null &amp;&amp;
        !s.isShared()         &amp;&amp;
        s.thread != null;
}
</code></pre><p>公平：如果有前驱节点在排队，则阻塞。</p>
<pre><code>static final class FairSync extends Sync {
    private static final long serialVersionUID = -2274990926593161451L;
    final boolean writerShouldBlock() {
        return hasQueuedPredecessors();
    }
    final boolean readerShouldBlock() {
        return hasQueuedPredecessors();
    }
}
</code></pre><h2 id="写锁的获取和释放"><a href="#写锁的获取和释放" class="headerlink" title="写锁的获取和释放"></a>写锁的获取和释放</h2><h4 id="获取过程-2"><a href="#获取过程-2" class="headerlink" title="获取过程"></a>获取过程</h4><p>获取写锁时必须没有读锁。</p>
<pre><code>protected final boolean tryAcquire(int acquires) {
        /*
         * Walkthrough:
         * 1. If read count nonzero or write count nonzero
         *    and owner is a different thread, fail.
         * 2. If count would saturate, fail. (This can only
         *    happen if count is already nonzero.)
         * 3. Otherwise, this thread is eligible for lock if
         *    it is either a reentrant acquire or
         *    queue policy allows it. If so, update state
         *    and set owner.
         */
        Thread current = Thread.currentThread();
        int c = getState();
        int w = exclusiveCount(c);
        if (c != 0) {
            // (Note: if c != 0 and w == 0 then shared count != 0)
            //当state不为0，可能是有读锁或者是有写锁，如果写锁为0，当前线程不是拥有锁的线程，则获取失败。
            if (w == 0 || current != getExclusiveOwnerThread())
                return false;
            if (w + exclusiveCount(acquires) &gt; MAX_COUNT)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            // Reentrant acquire
            //如果写锁不为0，那么读锁肯定为0，当前线程拥有锁，直接重入，获取成功。
            setState(c + acquires);
            return true;
        }
        //由公平性策略检查是否需要阻塞
        if (writerShouldBlock() ||
            !compareAndSetState(c, c + acquires))
            return false;
        setExclusiveOwnerThread(current);
        return true;
    }
</code></pre><h4 id="释放过程-2"><a href="#释放过程-2" class="headerlink" title="释放过程"></a>释放过程</h4><p>先检查当前线程是否拥有锁，然后将state写锁计数部分减去释放数。</p>
<pre><code>protected final boolean tryRelease(int releases) {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        int nextc = getState() - releases;
        boolean free = exclusiveCount(nextc) == 0;
        if (free)
            setExclusiveOwnerThread(null);
        setState(nextc);
        return free;
    }
</code></pre><h2 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h2><h4 id="获取过程-3"><a href="#获取过程-3" class="headerlink" title="获取过程"></a>获取过程</h4><p>tryAcquireShared与fullTryAcquireShared代码有部分重复，tryAcquireShared就是先尝试获取，失败再进入fullTryAcquireShared，这里直接分析fullTryAcquireShared方法。读锁获取时必须没有写锁。</p>
<pre><code>final int fullTryAcquireShared(Thread current) {
        /*
         * This code is in part redundant with that in
         * tryAcquireShared but is simpler overall by not
         * complicating tryAcquireShared with interactions between
         * retries and lazily reading hold counts.
         */
        HoldCounter rh = null;
        for (;;) {
            int c = getState();
            if (exclusiveCount(c) != 0) {
                if (getExclusiveOwnerThread() != current)
                    return -1;
                // else we hold the exclusive lock; blocking here
                // would cause deadlock.
                //存在一个时刻，既没有读锁也没有写锁，但是此时可能一个读锁和一个同步队列中的写锁竞争
            } else if (readerShouldBlock()) {
                // Make sure we&apos;re not acquiring read lock reentrantly
                if (firstReader == current) {
                    // assert firstReaderHoldCount &gt; 0;
                } else {
                    if (rh == null) {
                        rh = cachedHoldCounter;
                        if (rh == null || rh.tid != current.getId()) {
                            rh = readHolds.get();
                            if (rh.count == 0)
                            //帮助GC
                                readHolds.remove();
                        }
                    }
                    if (rh.count == 0)
                        return -1;
                }
            }
            if (sharedCount(c) == MAX_COUNT)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
             //将整个过程放在一个自旋里，就是有可能前面的条件允许，但是多个读线程同时CAS修改state值时有可能失败，自旋保证条件允许的情况下一定能线程安全的修改成功。
            if (compareAndSetState(c, c + SHARED_UNIT)) {
            //为相应的读线程记录重入数目，并且为最后一个访问的线程设置缓存
                if (sharedCount(c) == 0) {
                    firstReader = current;
                    firstReaderHoldCount = 1;
                } else if (firstReader == current) {
                    firstReaderHoldCount++;
                } else {
                    if (rh == null)
                        rh = cachedHoldCounter;
                    if (rh == null || rh.tid != current.getId())
                        rh = readHolds.get();
                    else if (rh.count == 0)
                        readHolds.set(rh);
                    rh.count++;
                    cachedHoldCounter = rh; // cache for release
                }
                return 1;
            }
        }
    }
</code></pre><h4 id="释放过程-3"><a href="#释放过程-3" class="headerlink" title="释放过程"></a>释放过程</h4><p>代码逻辑：先将ThreadLocal变量中对应线程的重入计数值减1，并注意清除不再使用的ThreadLocal变量帮助GC，最后用循环CAS设置state读数目。</p>
<pre><code>protected final boolean tryReleaseShared(int unused) {
        Thread current = Thread.currentThread();
        if (firstReader == current) {
            // assert firstReaderHoldCount &gt; 0;
            if (firstReaderHoldCount == 1)
                firstReader = null;
            else
                firstReaderHoldCount--;
        } else {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != current.getId())
                rh = readHolds.get();
            int count = rh.count;
            if (count &lt;= 1) {
                readHolds.remove();
                if (count &lt;= 0)
                    throw unmatchedUnlockException();
            }
            --rh.count;
        }
        for (;;) {
            int c = getState();
            int nextc = c - SHARED_UNIT;
            if (compareAndSetState(c, nextc))
                // Releasing the read lock has no effect on readers,
                // but it may allow waiting writers to proceed if
                // both read and write locks are now free.
                return nextc == 0;
        }
    }
</code></pre><hr>
<h1 id="条件变量-1"><a href="#条件变量-1" class="headerlink" title="条件变量"></a>条件变量</h1><p>由于条件变量的条件常常与共享资源的状态有关，条件变量常常与互斥量一起使用，也就使得在条件变量上的wait()/notify()操作必须要先获取互斥量。ConditionObject作为AQS的内部类也合情合理。实际上，在Lock接口中的newCondition()方法也表明了ConditionObject对象对锁的依赖性。由此，对于ConditionObject类的方法就不需要再另外做同步了。</p>
<p>每个对象都有wait()/notify()方法，在synchronized关键字的实现中，每一个对象一个管程，获取了对象的管程之后，才能进行wait()/notify()操作，一个对象一个条件变量。在许多场景下，线程需要在多个条件变量上阻塞，这时候synchronized关键字就无能为力了。但是AQS的条件变量没有这样的限制，可以创建多个条件变量ConditionObject。</p>
<p>ConditionObject实现了Condition接口，内部维护了一个带有首尾引用的FIFO单链表。节点类型依然为Node。主要有三类方法：await、notify和监控方法，其中await也提供了不可中断、可中断、超时三类方法。</p>
<h2 id="await-notify机制主要逻辑："><a href="#await-notify机制主要逻辑：" class="headerlink" title="await/notify机制主要逻辑："></a>await/notify机制主要逻辑：</h2><p>假设有线程A和线程B，线程A先获取锁，执行….，然后在某个conditionObject上await，调用await意味着线程A释放了其获得的锁并进入等待队列阻塞自己（注意：此时await方法并没有返回）。</p>
<p>线程B此时可以获取锁，执行….，在A线程等待的conditionObject上调用signal方法，将A线程从等待队列中移至锁的同步队列中去竞争锁，然后B线程释放锁。</p>
<p>此时A线程在同步队列中再次竞争到锁，然后此时await方法才返回，A线程继续执行await方法之后的代码。await有一个隐式的释放锁-阻塞-获取锁的过程。</p>
<h2 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h2><p>当一个线程在条件对象上等待时，先检查条件队列中是否有已取消的线程，如果有则清除（这里由于条件队列是单链表，每次清除都需要从头到尾遍历一遍），然后以当前线程构建新的节点，节点类型为CONDITION，加入条件队列。</p>
<pre><code>private Node addConditionWaiter() {
        Node t = lastWaiter;
        // If lastWaiter is cancelled, clean out.
        if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {
            unlinkCancelledWaiters();
            t = lastWaiter;
        }
        Node node = new Node(Thread.currentThread(), Node.CONDITION);
        if (t == null)
            firstWaiter = node;
        else
            t.nextWaiter = node;
        lastWaiter = node;
        return node;
    }

public final void awaitUninterruptibly() {
        Node node = addConditionWaiter();
        //入队以后，当前线程需要释放锁，不论是读锁还是写锁，释放锁调用的是AQS的release方法，tryRelease后，就会唤醒同步队列中的后继节点竞争锁。
        int savedState = fullyRelease(node);
        boolean interrupted = false;
        //然后线程循环检测自己是否在同步队列上（后面将分析signal()方法主要是将Condition节点移至锁对象所维护的同步队列上），如果不在同步队列表示自己仍需在条件对象上等待，如果已经在同步队列，线程从循环中退出。
        while (!isOnSyncQueue(node)) {
            LockSupport.park(this);
            if (Thread.interrupted())
                interrupted = true;
        }
        //等待的线程节点由等待队列进入同步队列，通过acquireQueued参与到锁的竞争中去。前面讲过这个方法，如果有机会就尝试获取锁。如果自己前面还有线程在等待，则将前者的状态设置为SIGNAL，然后自己阻塞等待前驱节点的唤醒。
        //如果获取锁成功，再处理中断情况，await方法返回（条件已经满足了），继续执行后面的代码。也就是说await方法返回时，是一定再次获取了锁的。
        if (acquireQueued(node, savedState) || interrupted)
            selfInterrupt();
    }
</code></pre><h2 id="signal方法"><a href="#signal方法" class="headerlink" title="signal方法"></a>signal方法</h2><p>siganl方法只做一个事情：将条件变量等待队列的节点移至锁的同步队列，这样在条件变量上等待的线程就可以参与锁的竞争，当那些线程获取到锁后即从await方法中返回，继续执行。signalAll即将所有等待队列上的节点都转移至同步队列参与竞争。<br>signal方法主要调用了transferForSignal方法：</p>
<pre><code>final boolean transferForSignal(Node node) {
    /*
     * If cannot change waitStatus, the node has been cancelled.
     */
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;

    /*
     * Splice onto queue and try to set waitStatus of predecessor to
     * indicate that thread is (probably) waiting. If cancelled or
     * attempt to set waitStatus fails, wake up to resync (in which
     * case the waitStatus can be transiently and harmlessly wrong).
     */
     //将节点移至同步队列队尾
    Node p = enq(node);
    int ws = p.waitStatus;
    //如果前驱节点无法通知该节点，则唤醒该节点的线程，该线程自己要么去竞争锁，要么维护同步队列（清除取消节点）并设置其前驱节点的状态为SIGNAL
    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}
</code></pre><hr>
<h1 id="可中断和超时"><a href="#可中断和超时" class="headerlink" title="可中断和超时"></a>可中断和超时</h1><p>AQS中获取锁的中断和ConditionObject的中断机制稍有不同，我们分开讲。</p>
<h2 id="锁的获取"><a href="#锁的获取" class="headerlink" title="锁的获取"></a>锁的获取</h2><p>主要涉及的方法有acquire和acquireInterruptibly，acquireShared和acquireSharedInterruptibly。</p>
<p>再来看acquire和acquireInterruptibly的源码：</p>
<pre><code>public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
public final void acquireInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
}
</code></pre><p>主要区别在于tryAcquire失败后的处理，再看acquireQueued：</p>
<pre><code>final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                //在成功获取锁后将中断信息返回，最终在acquire中再次调用selfInterrupt方法设置线程中断标志位
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
            //在检查到被中断后只是将中断标志位设置为true
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre><p>而acquireInterruptibly呢：</p>
<pre><code>private void doAcquireInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
             //在检查到有中断发生后直接抛异常   
                throw new InterruptedException();
        }
    } finally {
    //抛异常会导致获取锁失败，进而该获取锁线程节点被取消
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre><p>acquireShared和acquireSharedInterruptibly的中断机制与上述一致，不再赘述。</p>
<h2 id="ConditionObject–await方法的中断机制"><a href="#ConditionObject–await方法的中断机制" class="headerlink" title="ConditionObject–await方法的中断机制"></a>ConditionObject–await方法的中断机制</h2><p>在Doug Lea的论文<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">The java.util.concurrent Synchronizer Framework</a>中有这么一段话：</p>
<blockquote>
<p>As revised in JSR133, these require that if an interrupt occurs before a signal,then the await method must, after re-acquiring the lock, throw InterruptedException.   But   if   it   is   interrupted   after a signal,   then   the   method   must   return   without   throwing  an exception, but with its thread interrupt status set.</p>
</blockquote>
<p>按照JSR133的要求，在signal之前被中断的线程在重新获取锁后要抛InterruptedException，而在signal之后被中断的线程从await返回时不能抛异常，而是设置线程的中断标志位。也就是说在线程处于等待阶段时，抛出异常；在竞争锁阶段，设置标志位。</p>
<p>源码中也定义了两个变量来表示这两种情况：</p>
<pre><code>/** Mode meaning to reinterrupt on exit from wait */
    private static final int REINTERRUPT =  1;
    /** Mode meaning to throw InterruptedException on exit from wait */
    private static final int THROW_IE    = -1;
</code></pre><p>  并在可中断的await方法后面都加入了方法：</p>
<pre><code>private void reportInterruptAfterWait(int interruptMode)
      throws InterruptedException {
      if (interruptMode == THROW_IE)
          throw new InterruptedException();
      else if (interruptMode == REINTERRUPT)
          selfInterrupt();
  }
</code></pre><p>根据情况的不同await方法退出时有不同的处理。</p>
<p>以await()方法为例，我们来看它是如何做到的：</p>
<pre><code>public final void await() throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        int interruptMode = 0;

        while (!isOnSyncQueue(node)) {
            LockSupport.park(this);
            //这里有一个check方法
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
        }
        if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null) // clean up if cancelled
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
    }
</code></pre><p>解决问题的关键在于Node节点的状态。当节点处于等待队列中时，Node的状态为Condition。当节点被移至同步队列中后（signal后），Node的状态为0。</p>
<p>当线程在等待队列中等待时，如果有中断发生，线程从park()方法返回（park()方法也可能无端返回，这里略去），进入checkInterruptWhileWaiting方法：</p>
<pre><code>private int checkInterruptWhileWaiting(Node node) {
        return Thread.interrupted() ?
            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
            0;
    }
</code></pre><p>   重点看其中的transferAfterCancelledWait方法：</p>
<pre><code>   final boolean transferAfterCancelledWait(Node node) {
   //如果此时CAS操作成功了，证明还没有signal信号将节点移至同步队列，也就是中断发生在等待阶段。那么本操作将节点移至同步队列，返回true。这里返回true，即指示await方法返回时要抛出异常
    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
        enq(node);
        return true;
    }
    /*
     * If we lost out to a signal(), then we can&apos;t proceed
     * until it finishes its enq().  Cancelling during an
     * incomplete transfer is both rare and transient, so just
     * spin.
     */
     //如果操作失败了，说明该节点要么已经在同步队列上了，要么就在去同步队列的路上，等待一下
    while (!isOnSyncQueue(node))
        Thread.yield();
    return false;//返回false则指示await()返回时设置中断标志位 不抛异常
}
</code></pre><p>再来分析await方法中进入同步队列后的情况：</p>
<pre><code>//如果在获取锁的过程中发生中断，属于设置标志位的情况。这里也可以看到调用的是acquire方法中的acquireQueued方法，不可中断，即中断发生了我只是做记录，并不对中断做什么处理，做下记录留给专门处理中断的代码去处理。
if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null) // clean up if cancelled
            unlinkCancelledWaiters();
        if (interruptMode != 0)
        //如果这两个阶段发生了中断的话，最后由该方法向调用线程报告中断情况，是抛出异常还是仅仅设置标志位
            reportInterruptAfterWait(interruptMode);
    }
</code></pre><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>超时部分比较简单，获取锁的过程中超时了直接返回获取失败，等待过程中超时了直接不再等待，移至同步队列中竞争锁。</p>
<h1 id="监控方法"><a href="#监控方法" class="headerlink" title="监控方法"></a>监控方法</h1><p>AQS中提供了不少监控同步队列和等待队列的状态的方法，这些方法在并发环境下获取的信息都是估计值，瞬时值。</p>
<blockquote>
<p>Java并发编程的艺术<br>JSR133<br>Doug Lea的论文<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">The java.util.concurrent Synchronizer Framework</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/02/Java并发机制（3）--synchronized关键字底层原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John What">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/11/02/Java并发机制（3）--synchronized关键字底层原理/" class="post-title-link" itemprop="url">Java并发机制（3）--synchronized关键字底层原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-11-02 10:32:52" itemprop="dateCreated datePublished" datetime="2017-11-02T10:32:52+08:00">2017-11-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 20:06:32" itemprop="dateModified" datetime="2019-01-24T20:06:32+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>synchronized关键字在Java语言层面提供了同步功能。</p>
<h1 id="synchronized同步的形式"><a href="#synchronized同步的形式" class="headerlink" title="synchronized同步的形式"></a>synchronized同步的形式</h1><p>Java中的任何对象都可以被锁。<br>有以下三种形式：</p>
<ul>
<li>对于普通同步方法，锁住的是当前实例对象</li>
<li>对于静态同步方法，锁住的是当前类的Class对象</li>
<li>对于同步方法块，锁住的是synchronized括号里配置的对象</li>
</ul>
<p>这三种形式在jvm里都是由管程来支撑的。<br>同步代码块在字节码层面插入了monitorenter和monitorexit指令，用于实现对管程的调用。<br>方法级的同步是隐式的，不需要在字节码中插入指令，它实现在方法调用和返回之中。JVM从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志位来确定一个方法是否为同步方法。如果调用指令检查到方法为同步方法，则JVM要求当前执行线程必须先成功持有管程。</p>
<h1 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h1><p>在hotspot虚拟机中，synchronized用的锁存在Java对象头里。非数组对象头分为两部分：</p>
<ol>
<li>Mark Word，存储对象自身的运行时数据，如hashcode,GC分代年龄，锁标志位等。</li>
<li>存储指向方法去对象类型数据的指针</li>
</ol>
<p>ps:数组对象额外一部分用于存储数组的长度。</p>
<p>在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。<br>|锁状态|存储内容|锁标志位|<br>|—-|||<br>|无锁|对象hashcode，GC分代年龄，偏向锁标志位：0|01|<br>|偏向锁|ThreadID，Epoch，对象分代年龄，偏向锁标志位：1|01|<br>|轻量级锁|指向栈中锁记录的指针/|00|<br>|重量级锁|指向互斥量（重量级锁）的指针/|10|<br>|GC标记|空/|11|</p>
<h1 id="JVM线程状态转化机制"><a href="#JVM线程状态转化机制" class="headerlink" title="JVM线程状态转化机制"></a>JVM线程状态转化机制</h1><p>线程阻塞/等待队列图：<br><img src="http://johnlw.cn/blog_thread_block_wait.jpg" alt="JVM协调结构图"></p>
<p>工作原理：当多个线程同时请求某个管程时，管程会设置几种状态来区分和组织协调请求的线程</p>
<ul>
<li>Contention List:所有请求锁的线程首先添加至竞争队列</li>
<li>Entry List:Contention List中有资格成为候选线程的添加至Entry List</li>
<li>Wait Set:调用wait()方法阻塞的线程添加至wait set</li>
<li>OnDeck:任何时候最多只能有一个线程正在竞争锁，即OnDeck</li>
<li>Owner:获得锁的线程</li>
<li>！Owner;释放锁的线程</li>
</ul>
<p>具体过程：<br>Contention List:<br>当有新线程竞争管程时，先添加至Contention List。Contention List是一个LIFO队列，新线程通过CAS操作将队列头节点设置为自己，再将next引用指向之前的头结点。Owner线程从队列尾取元素。<br>Entry List:<br>Entry List 和Contention List逻辑上同属等待队列，因为Contention List会被多个线程并发访问，就涉及到等待或者阻塞，为了尽可能利用CPU时间，建立Entry List。Owner线程在unlock时会从Contention List中迁移线程至Entry List，并指定EntryList的head节点为OnDeck。Owner并不是直接将锁传递给OnDeck，而是将竞争锁的权利交给OnDeck，OnDeck需要重新竞争锁，也就是由OnDeck主动获取。正如前面所说，Owner线程会与其他线程并发访问Contention List，存在等待或者阻塞的情况，如果让Owner线程直接交给OnDeck锁，就有可能出现Owner线程阻塞在Contention List上而不能及时将锁交付，浪费CPU时间。<br>Wait Set:<br>如果Owner线程被wait方法阻塞，则转移到WaitSet队列，当在某个时刻被notify/notifyAll唤醒，则再次转移到EntryList。</p>
<h1 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h1><p>在Contention List和Entry List中的线程均处于BLOCKED状态，Wait Set中的线程处于WAITING状态，所以直接进入等待队列会引起线程上下文切换。实际上，很多时候共享数据的锁定状态只会持续很短的时间，为了这段时间去阻塞和恢复线程并不值得。当发生竞争时，竞争线程在队列外自旋一段时间，在Owner线程释放锁之后，竞争线程可能立即得到锁，从而避免了线程阻塞带来的开销。</p>
<h1 id="锁升级机制"><a href="#锁升级机制" class="headerlink" title="锁升级机制"></a>锁升级机制</h1><p>Java 1.6引入了锁升级机制，提高了synchronized的同步性能。锁一共有四种状态：无锁、偏向锁、轻量级锁、重量级锁，这几个状态随着竞争情况的越来越激烈而逐步升级。锁只能升级而不能降级。</p>
<p>线程每次尝试竞争锁时，会首先在当前线程栈帧中建立一个锁记录（Lock Record），用于存储该对象Mark Word的拷贝（Displaced Mark Word）。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，由此背景引入了偏向锁。</p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>当一个对象Mark Word中的锁标志位为01（无锁/可偏向）时，</p>
<ol>
<li>当偏向锁标志位为0时，说明不是偏向锁，该对象管程未被任何线程获取，当前线程通过CAS操作尝试在对象Mark Word中记录当前线程ID，同时将偏向锁标志位置为1，当前线程即持有该对象的偏向锁。从此以后，持有偏向锁的线程进入该对象管程时，虚拟机将不再做任何同步操作。</li>
<li>当偏向锁标志位为1时，说明该对象已经有所偏向，如果偏向线程ID并不是当前线程，则尝试用CAS操作在Mark Word中记录自己的线程ID，如果成功，则该对象重偏向至当前线程。<h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3>如果重偏向失败，即已经出现竞争，偏向锁才会解锁。根据锁对象是否处于被锁定的状态，撤销偏向后对象要么重偏向，要么恢复到无锁状态，要么升级为轻量级锁–将锁标志位置为00。</li>
</ol>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><h3 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h3><p>当偏向锁膨胀为轻量级锁后，线程再次竞争锁时，将使用CAS尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功，则当前线程进入管程。如果失败，当前线程自旋获取锁。如果自旋获取锁失败，则竞争情况变得更加激烈了，锁膨胀为重量级锁，锁标志位置为10，同时当前线程进入阻塞态。</p>
<h3 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h3><p>轻量级锁解锁时，会使用CAS操作尝试将Displaced Mark Word替换回对象头上，如果成功，则表示在执行同步代码期间没有竞争发生或者竞争线程自旋没有结束。如果失败，说明其他线程在同步期间竞争失败了，在释放锁的同时，需要唤醒阻塞线程。</p>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>重量级锁的加锁和解锁由状态转化机制协调。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table>
<thead>
<tr>
<th>锁</th>
<th>背景</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得</td>
<td>加锁和解锁过程没有额外的开销</td>
<td>如果存在竞争，将带来额外的撤销开销</td>
<td>竞争不激烈的情况</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>在许多应用中，共享数据的锁定状态只会持续很短的一段时间</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果自旋竞争失败，会浪费CPU时间，还额外带来了CAS操作的开销（重量级锁没有CAS操作）</td>
<td>同步块执行速度非常快的情况</td>
</tr>
<tr>
<td>重量级锁</td>
<td>竞争激烈情况下必须程序正确同步</td>
<td>线程竞争不使用自旋，不会浪费CPU</td>
<td>线程阻塞，用户态内核态的切换，线程上下文切换等开销</td>
<td>竞争激烈，同步块执行时间长</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.7.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>




  

  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  




  





  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
