<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="The Old John">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="The Old John">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="The Old John">






  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>The Old John</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">The Old John</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/31/Java并发机制（2）--volatile关键字/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Old John">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/10/31/Java并发机制（2）--volatile关键字/" class="post-title-link" itemprop="url">Java并发机制（2）--volatile关键字</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-10-31 11:04:47" itemprop="dateCreated datePublished" datetime="2017-10-31T11:04:47+08:00">2017-10-31</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 17:25:51" itemprop="dateModified" datetime="2019-01-24T17:25:51+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关键字volatile提供了轻量级的同步机制，在理解volatile关键字之前先来看几个支撑技术。</p>
<h1 id="有序性的一种保证方式：内存屏障"><a href="#有序性的一种保证方式：内存屏障" class="headerlink" title="有序性的一种保证方式：内存屏障"></a>有序性的一种保证方式：内存屏障</h1><p>内存屏障是一组指令，分4类，这些指令指定了其前后指令的排序规则。</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad Barrier</td>
<td>Load1;LoadLoad;Load2</td>
<td>确保load1数据的装载先于load2及其后续所有load指令</td>
</tr>
<tr>
<td>StoreStore Barrier</td>
<td>Store1;StoreStore;Store2</td>
<td>确保Store1数据刷新到内存先于Store2及其后续所有store指令</td>
</tr>
<tr>
<td>LoadStore Barrier</td>
<td>Load1;LoadStore;Store2</td>
<td>确保load1数据的装载先于Store2及其后续所有store指令</td>
</tr>
<tr>
<td>StoreLoad Barrier</td>
<td>Store1;StoreLoad;Load2</td>
<td>确保Store1数据刷新到内存先于load2及其后续所有load指令 。<strong>注意</strong>：StoreLoad Barriers会使该屏障之前的所有内存访问指令（包括load和store指令）都执行完了之后，再执行屏障之后的内存访问指令。</td>
</tr>
</tbody>
</table>
<p>也就是说，在一个指令序列中插入了内存屏障，这些内存屏障会限制其前后指令的排序，而在两个内存屏障之间代码序列的重排序则没有约束。就好像屏障一样，被限制的指令无法越过。<br>同时也可以看出内存屏障将缓存值刷新到内存也起到了提供可见性的作用。</p>
<h1 id="强大的汇编指令前缀：Lock"><a href="#强大的汇编指令前缀：Lock" class="headerlink" title="强大的汇编指令前缀：Lock"></a>强大的汇编指令前缀：Lock</h1><p>lock前缀有三方面的功能：</p>
<ol>
<li>确保对内存的读-改-写操作原子执行。</li>
<li>禁止该指令，与之前和之后的读写指令重排序。</li>
<li>将写缓冲区的所有数据刷新到内存中，并且这个写操作会使其他CPU里缓存了该内存地址的数据无效。</li>
</ol>
<p>其中第2条和第3条共同起到了内存屏障的效果，并且是一并禁止了load和store指令。<br>可以看出，单单一个lock前缀就提供了原子性、有序性和可见性的三方面的可靠保证。</p>
<h1 id="volatile修饰变量"><a href="#volatile修饰变量" class="headerlink" title="volatile修饰变量"></a>volatile修饰变量</h1><p>被volatile修饰的变量有三个特性：</p>
<ol>
<li>原子性。对任意单个volatile变量的读、写具有原子性，但类似于volatile++这种<strong>复合操作</strong>没有原子性。</li>
<li>可见性。对一个volatile的读，总是能看到任意线程对这个变量的最后一次写入。</li>
<li>有序性。volatile禁止指令重排序。</li>
</ol>
<p>之所以volatile具有这三个特性，在于对volatile变量的操作有lock prefix支持。lock prefix提供了三方面的特性保证。</p>
<h1 id="锁与volatile"><a href="#锁与volatile" class="headerlink" title="锁与volatile"></a>锁与volatile</h1><p>锁的释放与volatile写具有同样的内存语义：释放锁和对volatile变量的写，JMM都会把线程对应的本地内存中的共享变量刷新到主内存中。<br>锁的获取与volatile读具有同样的内存语义：获取锁和对volatile变量的读，JMM都会将线程对应的本地内存置为无效，而是从主内存中重新读取。</p>
<h1 id="CAS与volatile"><a href="#CAS与volatile" class="headerlink" title="CAS与volatile"></a>CAS与volatile</h1><p>CAS操作具有volatile读和写的内存语义。该操作在执行cmpxchg指令之前，如果是多处理器，将会插入lock前缀。lock前缀提供了与volatile一致的内存语义。</p>
<h1 id="volatile重排序例子"><a href="#volatile重排序例子" class="headerlink" title="volatile重排序例子"></a>volatile重排序例子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"> </span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
<p>有可能语句2会在语句1之前执行，那么就可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<blockquote>
<p>现代操作系统<br>Java并发编程的艺术<br>深入理解Java虚拟机<br>Java并发编程实战<br>JSR-133<br>并发编程网<br>Intel IA-32</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/25/Java并发机制（1）--理论基础/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Old John">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/10/25/Java并发机制（1）--理论基础/" class="post-title-link" itemprop="url">Java并发机制（1）--理论基础</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-10-25 14:16:14" itemprop="dateCreated datePublished" datetime="2017-10-25T14:16:14+08:00">2017-10-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 17:24:16" itemprop="dateModified" datetime="2019-01-24T17:24:16+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进程与线程概念"><a href="#进程与线程概念" class="headerlink" title="进程与线程概念"></a>进程与线程概念</h1><p>在现代操作系统中，进程支持多线程。</p>
<ul>
<li>进程是<strong>资源管理</strong>的最小单元，</li>
<li>线程是<strong>程序执行</strong>的最小单元。</li>
</ul>
<p>线程作为调度和分配的基本单位，进程作为资源分配的基本单位。</p>
<p>一个进程的组成实体可以分为两大部分：线程集和资源集。进程中的线程是动态的对象；代表了进程指令的执行。资源，包括地址空间、打开的文件、用户信息等等，由进程内的线程共享。</p>
<h1 id="多道程序设计模型"><a href="#多道程序设计模型" class="headerlink" title="多道程序设计模型"></a>多道程序设计模型</h1><p>计算机采用多道程序设计模型可以显著提高CPU的利用率。</p>
<h1 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h1><p>多进程：并行实体之间<strong>不共享</strong>同一个地址空间和所有可用数据。<br>多线程：并行实体之间<strong>共享</strong>同一个地址空间和所有可用数据。<br>1、线程比进程更加轻量级，线程的创建、切换等过程比进程开销小，线程的通信比进程间的通信简单。<br>2、进程的安全性高于线程，因为不共享。</p>
<h1 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h1><ul>
<li>内核线程实现</li>
<li>用户线程实现</li>
<li>用户线程加轻量级进程混合实现</li>
</ul>
<p><strong>Java线程实现</strong>在linux和windows平台上均采用的是内核线程实现，Java线程与内核线程为一比一的对应关系，也就是说Java线程由内核直接调度。</p>
<h1 id="多线程面临的挑战"><a href="#多线程面临的挑战" class="headerlink" title="多线程面临的挑战"></a>多线程面临的挑战</h1><ul>
<li>线程通信</li>
<li>上下文切换</li>
<li>死锁</li>
<li>资源限制</li>
<li>线程安全<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2>多线程相当于是多个线程为了完成<strong>一件</strong>“大事”而<strong>协同</strong>工作，那这多个线程之间如何协同就是线程通信的问题了。<br>线程间的通信是多线程编程的基础，线程间通信方式有两种：共享内存和消息传递。Java线程间的通信机制为共享内存方式。<br>线程间通信就要保证通信的可靠性，确保信息的可靠传递。这就涉及到线程安全的问题。<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2>线程安全最核心的概念是<strong>正确性</strong>。</li>
</ul>
<p><strong>在操作系统中</strong>，正确性是指多个线/进程读写共享数据，最后的结果与线/进程运行的精准时序无关，亦即<strong>不存在竞争条件</strong>。<br><strong>在Java中</strong>，正确性是指：某个类的行为与其规范完全一致。当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p>
<p>可以将Java线程安全按由强到弱分为5类，同时也可以看到线程安全的责任由对象本身向调用者的转移：</p>
<ol>
<li>不可变<br>不可变对象一定是线程安全的，无论是对象的方法还是方法的调用者，都不需要再采取任何的线程安全保障措施。（final关键字的使用）</li>
<li>绝对线程安全<br>不管运行时环境如何，调用者都不需要任何额外的同步措施。这个要求非常严格，Java API中大多数都不是绝对线程安全的类。</li>
<li>相对线程安全<br>保证对某个对象的单独操作是线程安全的，在调用的时候不需要做额外的同步措施。但是对于同一个对象的特定顺序的连续调用，可能需要在调用端做额外的同步手段（多为扩大同步范围）来保证调用的正确性。Java中大部分线程安全类属于相对线程安全。</li>
<li>线程兼容<br>对象本身不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境下的线程安全性。Java中的普通类。</li>
<li>线程对立<br>无论调用端是否采取了同步措施，都无法在并发环境中使用。</li>
</ol>
<h1 id="多线程编程的出发点"><a href="#多线程编程的出发点" class="headerlink" title="多线程编程的出发点"></a>多线程编程的出发点</h1><p>并发编程的基本出发点：<strong>先保证正确性，再提高效率</strong>。</p>
<p>保证正确性有三种方式：</p>
<ul>
<li>互斥同步</li>
<li>非阻塞同步</li>
<li>无同步方案</li>
</ul>
<p>互斥同步由互斥量（操作系统级或者Java语言级）支持，非阻塞同步由CAS指令支持，无同步方案为可重入代码和Java中的ThreadLocal变量。</p>
<p>提高效率中很重要的方式有重排序和减少上下文切换等。</p>
<hr>
<h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p>先来看一个最基础的支撑技术。</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子（atom）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。如有些场景下需要将读取变量值，再修改其值，再写入内存合并为一个原子操作完成。</p>
<p>intel处理器使用基于对缓存加锁和总线加锁的方式来实现多处理器之间的原子操作。<br>总线加锁：使用处理器提供的lock# 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞，该处理器可以独占共享内存。<br>缓存加锁：内存区域如果被缓存在处理器的缓存行中，并且在lock操作期间被锁定，那么当处理器执行锁操作回写到内存时，处理器修改内部的内存地址，通过缓存一致性协议来保证操作的原子性和可见性。缓存一致性协议会阻止同时修改由两个一上处理器缓存的内存数据，当处理器回写被锁定的缓存行的数据时，会使其他处理器的缓存行失效，其他处理器在下次读取时将重新从共享内存中读取。<br>可以看出原子操作的同时也提供了可见性。</p>
<p>再看操作系统如何保证正确性。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>对共享内存进行访问的程序片段成为临界区。<br>如果可以协调多线/进程不可能同时处于临界区，就能避免竞争条件（即互斥），从而保证正确性。同时在协调机制中也尽可能要求高效，一个好的协调方案，要满足以下4个条件：</p>
<ul>
<li>任何两个进/线程不能同时处于临界区</li>
<li>不应对CPU的速度和数量做任何假设（单核、多核、超线程） </li>
<li>临界区外运行的进/线程不得阻塞其他进/线程</li>
<li>不得使进/线程无限期等待进入临界区</li>
</ul>
<p>其中前两个条件是对正确性的保证，后两个条件是对效率的保证。</p>
<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>在原子操作的支撑下，有多种方案可以实现互斥。大体分为两类：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原理</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>忙等待</td>
<td>定义共享变量，设定某个值表示是否有线程进入临界区。如果已有线程进入，则各线程对该变量进行轮询，自旋等待，直到进入临界区</td>
<td>CPU自旋等待，如果短期内能进入临界区，避免了线程阻塞和上下文切换带来的开销</td>
<td>CPU空转，同时存在优先级反转问题</td>
<td>在有理由认为等待时间是非常短的情况下使用</td>
</tr>
<tr>
<td>等待/通知机制</td>
<td>一样定义共享变量，但是如果已有线程进入，则后面的线程将阻塞，当之前的线程出临界区时通知等待的线程进入临界区执行。</td>
<td>不会出现CPU空转，CPU占用极高的情况</td>
<td>线程阻塞将带来线程切换上下文的开销</td>
<td>临界区竞争激烈，且执行时间较长的情况下使用</td>
</tr>
</tbody>
</table>
<p>表格中的共享变量既可以使用信号量也可以使用互斥量，一般使用互斥量。</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>当仅有互斥量时且有线程在临界区时，其他线程将在互斥量上等待，然而很多情况下线程的执行不仅需要进入临界区，而且还需要满足一些其他的条件，当条件不满足时进入临界区线程不能继续执行也没有什么意义。这时候就需要条件变量了。</p>
<p>这时，一个线程运行需要条件变量满足，并且能锁住互斥量。如果锁住了互斥量，然而需要在某个条件变量上等待，线程将释放互斥量（给别的线程机会），进入阻塞态，等待其他线程在条件变量上唤醒自己，转入就绪态继续竞争互斥量。</p>
<h3 id="管程（Monitor）"><a href="#管程（Monitor）" class="headerlink" title="管程（Monitor）"></a>管程（Monitor）</h3><p>通过互斥量、条件变量以及相关的原子操作即可保证多线程通信的正确性，不过在多线程中，存在发送给变量的信号可能会丢失的情况，还有可能会出现死锁的情况，如果直接面向这些量编写多线程程序，会不可避免的出现各种奇奇怪怪的问题。为了简化多线程程序的编写，管程出现了。</p>
<p>管程实际上可以理解为是对互斥量、条件变量、以及组织协调多线程进入临界区算法的一个封装。高层代码只需要临界区交给管程管理就好了，管程会保证正确性。</p>
<p>JVM中管程与经典管程有本质区别：Java没有内嵌的条件变量。Java将等待/通知机制提出来作为wait()/notify()供程序员自定义使用，自定义条件变量（如某个对象）。</p>
<h2 id="非阻塞方案"><a href="#非阻塞方案" class="headerlink" title="非阻塞方案"></a>非阻塞方案</h2><p>互斥同步最主要的问题就是进行线程阻塞和唤醒带来的性能问题。是一种悲观的同步方案：不管有没有竞争，都要加解锁。<br>非阻塞方案是一种基于冲突检测的乐观方案：先进行操作，如果没有竞争，则操作就成功了；如果有竞争，产生了冲突，则采取补偿措施（一般即为不断尝试直到成功），这种方案并不需要阻塞线程。</p>
<p>CMPXCHG指令，该指令是原子操作。简单理解，cmpxchg指令接受两个参数，一个是将要修改的变量的预期值，一个是修改值，指令比较预期值与变量的实际值是否一致，如果一致则将修改值赋值给变量。否则不做修改。<br>由于这个指令是主动比较，一般会放到自旋中，适用于冲突比较少的场景。</p>
<h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>如果方法中不涉及共享数据，那么该方法不需要做任何同步。</p>
<ol>
<li>可重入代码<br> 可重入代码的特征如不依赖公共数据，不调用非可重入代码等，可重入代码中多为局部变量，不与其他代码共享，也就不存在数据竞争了。</li>
<li>线程本地存储–ThreadLocal</li>
</ol>
<hr>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>再看提高执行效率的方式：指令重排序。<br>重排序分三种：1.编译器优化的重排序。2.指令级并行的重排序。3.内存系统的重排序</p>
<h3 id="单线程重排序"><a href="#单线程重排序" class="headerlink" title="单线程重排序"></a>单线程重排序</h3><h4 id="数据依赖"><a href="#数据依赖" class="headerlink" title="数据依赖"></a>数据依赖</h4><p>如果两个操作访问同一个变量，且两个操作中有一个为写操作（读写/写读/写写），此时这两个操作之间存在数据依赖性。如果对存在数据依赖性的操作重排序，程序执行结果将会改变。因此，编译器和处理器不会改变存在数据依赖性的操作的执行顺序。</p>
<h4 id="as-if-serial模型"><a href="#as-if-serial模型" class="headerlink" title="as-if-serial模型"></a>as-if-serial模型</h4><p>as-if-serial：不管怎么重排序，单线程执行的结果不能被改变。<br>1、对存在数据依赖性的操作重排序非法。<br>2、对不存在数据依赖性的操作是否重排序不做要求。<br>as-if-serial为单线程提供了顺序执行的保证。</p>
<h3 id="多线程重排序"><a href="#多线程重排序" class="headerlink" title="多线程重排序"></a>多线程重排序</h3><h4 id="冲突访问"><a href="#冲突访问" class="headerlink" title="冲突访问"></a>冲突访问</h4><p>多线程中，对同一个共享字段或者数组元素存在两个访问（读或写），且至少有一个访问为写操作，称之为有冲突。</p>
<h4 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h4><ul>
<li>冲突访问</li>
<li>读写操作没有通过同步来排序</li>
</ul>
<p>当上述情况发生时，就存在数据竞争。代码中出现数据竞争时，常有可能会出现有违直觉的结果。<br>那么如何判断程序有没有正确的同步呢？<br>一个程序是<strong>正确同步</strong>的：<strong>当且仅当所有顺序一致的执行过程中都不存在数据竞争。</strong>不论调度系统如何调度，所有可能的执行顺序序列下，都不存在数据竞争。</p>
<p>那么应该如何来组织多线程程序的同步排序呢？</p>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>给定一个程序和该程序的一串执行轨迹，内存模型描述了该执行轨迹是否是该程序的一次合法执行。内存模型检查执行轨迹中的每次读操作，然后根据特定规则，检验该读操作观察到的写是否合法。<br>内存模型的一个高级、非正式的概述显示其是一组规则，规定了一个线程的写操作何时会对另一个线程可见。</p>
<h2 id="顺序一致性模型"><a href="#顺序一致性模型" class="headerlink" title="顺序一致性模型"></a>顺序一致性模型</h2><p>顺序一致性是程序执行过程中    可见性和顺序的强有力保证。</p>
<ul>
<li>有序性</li>
<li>原子性</li>
<li>可见性</li>
</ul>
<p>有序性：在顺序一致的执行过程中，所有动作（如读和写）间存在一个全序关系，与程序的顺序一致。<br>原子性和可见性：每个动作都是原子的并且立即对所有线程可见。</p>
<p>顺序一致性模型是一个理论参考模型，它在提供了极强的操作有序性、原子性和可见性的同时，使编译器和处理器优化（比如重排序）不再合法。</p>
<h2 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h2><p>JSR-133中对happens-before的定义：</p>
<ol>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。<strong>（有序性和可见性）</strong></li>
<li><p>两个操作之间存在happens-before关系，并不意味着java平台的具体实现必须要按照happens-before关系指定的顺序来执行。只要结果与按照happens-before关系来执行的一致，编译器和处理器的重排序是合法的。（最大限度的减少对编译器和处理器优化的约束）</p>
</li>
<li><p>程序顺序规则<br> 在一个线程内，按照程序代码顺序，书写在前面的操作happens-before书写在后面的操作。</p>
</li>
<li>管程锁规则<br> 一个unlock操作happens-before后面对同一个锁的lock操作。</li>
<li>volatile变量规则<br> 对一个volatile变量的写操作happens-before后面对这个变量的读操作。</li>
<li>线程启动规则<br> Thread对象的start()方法happens-before此线程的每一个动作。</li>
<li>线程终止规则<br> 线程中所有操作都happens-before对此线程的终止检测。</li>
<li>线程中断规则<br> 对线程interrupt()方法的调用happens-before被中断线程的代码检测到中断事件的发生。</li>
<li>对象终结规则<br> 一个对象的初始化完成（构造函数执行完毕）happens-before它的finalize()方法。</li>
<li>传递性<br> A happens-before B,B happens-before C,s.t. A happens-before C.</li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li>happens-before首先强调了前一个操作对后一个操作的顺序和可见性，但是同时又没有限定具体实现，只要求执行结果要与happens-before一致。那么在实际的代码执行中，happens-before和代码时间上的先行发生并没有直接关系。</li>
<li>happens-before允许违反因果关系的事情发生。（比如：out of thin air）</li>
</ul>
<h2 id="happens-before和as-if-serial"><a href="#happens-before和as-if-serial" class="headerlink" title="happens-before和as-if-serial"></a>happens-before和as-if-serial</h2><ul>
<li>as-if-serial保证单线程内程序的执行结果不被改变。向上向程序员保证程序执行顺序，向下约束编译器和处理器重排序的规则。</li>
<li>happens-before关系保证正确同步的多线程程序的执行结果不被改变。向上向程序员保证正确同步的多线程程序的执行结果正确性，向下约束编译器和处理器重排序的规则。</li>
</ul>
<hr>
<p>顺序一致性模型不允许重排序-过于严格，happens-before允许违反因果关系的事情发生-过于宽松，都不适合作为Java内存模型。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><ol>
<li>Java线程间的通信机制，JMM决定一个线程对共享变量的写入何时对另外一个线程可见。</li>
<li>屏蔽各种硬件和操作系统的内存访问差异，实现java跨平台的一致的内存访问效果</li>
<li>向上向程序员保证正确同步的程序具有顺序一致性</li>
<li>向下向编译器和处理器提供尽可能宽松的重排序约束规则</li>
<li>在happens-before的基础上提供了对因果关系的充分保证</li>
</ol>
<p>从<strong>抽象</strong>的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程读写共享变量的副本。本地内存是JMM的一个抽象概念，实际并不存在，它涵盖了缓存、寄存器以及其他的硬件和编译器优化。<br>同时定义了工作内存与主内存的交互操作协议：lock、unlock、read、load、use、assign、store、write共8种原子性操作以及它们之间的操作规则。</p>
<h2 id="Java内存模型的特征"><a href="#Java内存模型的特征" class="headerlink" title="Java内存模型的特征"></a>Java内存模型的特征</h2><p>Java内存模型建立在解决三个并发问题的基础上。</p>
<ul>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ul>
<p>对于原子性的保证：有read、load、use、assign、store、write这类数据访问的基本原子性操作，更大范围的可以用lock和unlock操作来保证。<br>对于可见性的保证：Java内存模型通过主内存作为可见性实现的媒介。写操作刷新回主内存，读操作重新读主内存实现前一个操作对后一个操作的可见性。<br>对于有序性的保证：happens-before规则保证基本操作的有序性，通过同步来保证其他操作的有序性。</p>
<p>下一篇讲解Java内存模型的具体实现，看Java如何在允许指令重排序的情况下保证正确同步。</p>
<blockquote>
<p>现代操作系统<br>Java并发编程的艺术<br>深入理解Java虚拟机<br>Java并发编程实战<br>JSR-133<br>并发编程网</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/11/数据结构与算法基础概念总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Old John">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/05/11/数据结构与算法基础概念总结/" class="post-title-link" itemprop="url">数据结构与算法基础概念总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-05-11 21:08:28" itemprop="dateCreated datePublished" datetime="2017-05-11T21:08:28+08:00">2017-05-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 16:34:00" itemprop="dateModified" datetime="2019-01-24T16:34:00+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线性结构—–线性表"><a href="#线性结构—–线性表" class="headerlink" title="线性结构—–线性表"></a>线性结构—–线性表</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>具有相同数据类型数据元素的有限序列</p>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>逻辑上相邻的元素物理位置上也相邻，即数组</p>
<h3 id="链式表"><a href="#链式表" class="headerlink" title="链式表"></a>链式表</h3><p>逻辑上相邻的元素物理位置上不一定相邻，节点包含数据域和指针域，指针域指向后继节点。有单向链表，双向链表，循环链表。</p>
<h3 id="顺序与链式比较"><a href="#顺序与链式比较" class="headerlink" title="顺序与链式比较"></a>顺序与链式比较</h3><table>
<thead>
<tr>
<th>名称</th>
<th>存取方式</th>
<th>逻辑/物理结构</th>
<th>增删</th>
<th>查</th>
<th>空间分配</th>
<th>场景选择</th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序表</td>
<td>顺序/随机存取</td>
<td>逻辑物理均相邻</td>
<td>平均需要移动半个表的数据，O（N）</td>
<td>按值查找：无序O（N），有序二分查找O（logN）;按索引查找：O（1）</td>
<td>固定空间分配</td>
<td>固定空间，随机访问场景</td>
</tr>
<tr>
<td>链式表</td>
<td>顺序存取</td>
<td>逻辑物理不一定相邻</td>
<td>修改指针域即可，O（1），不过在链表中间插入或者删除需要先查找到相应元素，算上这部分时间就是O（N）</td>
<td>顺序访问O（N）</td>
<td>按需分配</td>
<td>不确定空间分配，插入/删除操作较多的场景（虽然有查找的时间，但是比较操作相对顺序表的移动操作更廉价）</td>
</tr>
</tbody>
</table>
<h1 id="操作受限的线性表"><a href="#操作受限的线性表" class="headerlink" title="操作受限的线性表"></a>操作受限的线性表</h1><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>只允许在一端进行插入和删除操作的线性表，FILO，顺序栈，链式栈</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>只允许在一端插入，而在另一端删除的线性表，FIFO</p>
<ul>
<li>顺序存储：顺序队列、循环队列</li>
<li>链式存储：单链表队列、双端队列（双入双出，双入单出，单入双出）</li>
</ul>
<h1 id="非线性结构—–树"><a href="#非线性结构—–树" class="headerlink" title="非线性结构—–树"></a>非线性结构—–树</h1><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><ul>
<li>图定义：树是无简单回路的有向连通图。</li>
<li>递归定义：树由根节点r和子树组成，每个子树的根节点都被来自r的边所连接<h3 id="路径、路径长、深度、高度、度"><a href="#路径、路径长、深度、高度、度" class="headerlink" title="路径、路径长、深度、高度、度"></a>路径、路径长、深度、高度、度</h3>从节点n1到nk的路径定义为n1,n2…nk这个节点序列，路径长为节点序列中边的条数。</li>
</ul>
<p><strong>深度和高度是基于路径的概念来定义的</strong>：节点n的深度为从根节点到n的唯一路径的长。节点n的高度定义为从节点n到一个叶子节点的最长路径的长。</p>
<p>节点的度：某节点孩子节点的个数</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>二叉树是每个节点都拥有不超过两个儿子的树。</p>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><ul>
<li>先序遍历：先根后左右儿子</li>
<li>中序遍历：先左儿子，再根，再右儿子</li>
<li>后序遍历：先左右儿子，再根</li>
<li>层序遍历：先根，再根的左右儿子根节点…需要借助队列</li>
</ul>
<h5 id="复原"><a href="#复原" class="headerlink" title="复原"></a>复原</h5><p>由先序序列和中序序列，后序序列和中序序列可以唯一的确定一棵二叉树，之所以都需要中序序列，是因为先序和后序只能确定根节点，而中序序列根据根节点的位置可以确定左右子树。</p>
<h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h5><p>树高度为h，含有2^h - 1个节点的二叉树，树中每一层都含有最多的节点。</p>
<h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><p>从插入元素的角度来说，完全二叉树就是按层序从上到下，从左往后插满每个节点，最后一层可以不插满</p>
<h5 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h5><p>一棵二叉树，其左子二叉树上的所有节点值都小于根节点，右子二叉树上的所有节点值都大于根节点。</p>
<h5 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h5><p>二叉树上任一节点的左子树和右子树的深度之差不超过1</p>
<h5 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h5><p>多路平衡查找树，m阶B树需要满足以下特性：</p>
<ul>
<li>根节点：至少有两棵子树</li>
<li>中间节点（非根非叶节点）：子树数目要求大于等于（m/2）（向上取整），小于等于m</li>
<li>叶结点：所有叶结点都在同一层次上</li>
</ul>
<h5 id="表达式树相关"><a href="#表达式树相关" class="headerlink" title="表达式树相关"></a>表达式树相关</h5><p>叶子节点存操作数，非叶子节点存操作符。<br>表达式树的中序遍历得中缀表达式，后序遍历得后缀表达式。</p>
<p>中缀表达式转后缀表达式：借助栈。读取中缀表达式，遇到操作数直接输出，遇到操作符即准备入栈，入栈前先比较栈顶操作符与当前操作符的优先级，如果栈顶优先级高或者平级，输出直至低优先级，然后再入栈。对于括号：左括号具有最高优先级，括号内的操作符出入栈跟之前一样，遇到右括号将操作符依次出栈直到左括号。注：括号不输出。</p>
<p>后缀表达式求值：借助栈。读取后缀表达式，操作数直接入栈，遇到操作符弹出两个操作数进行计算，结果入栈，继续读取…以此类推，直至结束</p>
<p>后缀表达式构建表达式树：借助栈。操作数作为单节点入栈，遇到操作符，以操作符作为根节点，弹出两个操作数作为右、左儿子，最后将操作符节点入栈…以此类推，直至结束</p>
<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><p>键值对的集合，通过散列函数计算键对应的值的存放位置，之后可以通过键直接访问值。</p>
<h5 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h5><p>将关键字映射到相应位置的函数。如果两个不同的key值，经散列后位置相同，这种情况称为冲突或者碰撞。</p>
<p>每次对散列表的操作，都需要经过散列函数，散列函数的选择应该简单以节省时间、散列均匀以避免碰撞。</p>
<h5 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h5><p>散列表中元素的个数与该表大小的比值。</p>
<h5 id="碰撞处理"><a href="#碰撞处理" class="headerlink" title="碰撞处理"></a>碰撞处理</h5><h6 id="分离连接法"><a href="#分离连接法" class="headerlink" title="分离连接法"></a>分离连接法</h6><p>将同一个散列值的不同元素保存在同一个链表里，并将后进入的元素放在链表的前端。</p>
<h6 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h6><p>出现碰撞以后，用新的函数继续找位置，直到找到空的位置为止</p>
<ul>
<li>线性探测：线性函数查找，会出现一次聚集</li>
<li>平方探测：二次函数查找，会出现二次聚集<h6 id="再散列（扩容）"><a href="#再散列（扩容）" class="headerlink" title="再散列（扩容）"></a>再散列（扩容）</h6>当散列表中元素的数量达到装填因子时，新建一个大的散列表，将原散列表中的元素重新计算散列值并放入新的散列表中<h1 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h1></li>
</ul>
<blockquote>
<p><a href="https://www.zhihu.com/question/20761771/answer/19996299" target="_blank" rel="noopener">https://www.zhihu.com/question/20761771/answer/19996299</a><br><a href="http://stackoverflow.com/questions/33923/what-is-tail-recursion" target="_blank" rel="noopener">http://stackoverflow.com/questions/33923/what-is-tail-recursion</a><br><a href="http://www.cnblogs.com/Anker/archive/2013/03/04/2943498.html" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/archive/2013/03/04/2943498.html</a></p>
</blockquote>
<h1 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h1><p><a href="http://blog.csdn.net/fanzheng220112583/article/details/7719228" target="_blank" rel="noopener">http://blog.csdn.net/fanzheng220112583/article/details/7719228</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/09/后缀表达式的计算器Java实现/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Old John">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/05/09/后缀表达式的计算器Java实现/" class="post-title-link" itemprop="url">后缀表达式的计算器Java实现</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-05-09 13:42:58" itemprop="dateCreated datePublished" datetime="2017-05-09T13:42:58+08:00">2017-05-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 15:35:18" itemprop="dateModified" datetime="2019-01-24T15:35:18+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>直接上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package cn.john.cal;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @ClassName: Operators</span><br><span class="line"> * </span><br><span class="line"> * @Description: 操作符枚举</span><br><span class="line"> * </span><br><span class="line"> * @author: John</span><br><span class="line"> * </span><br><span class="line"> * @date: 2017年5月9日 下午22:05:16</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public enum OperatorsEnum &#123;</span><br><span class="line"></span><br><span class="line">	PLUS(0, &apos;+&apos;), MINUS(0, &apos;-&apos;), MULTIPLY(1, &apos;*&apos;), DIVIDE(1, &apos;/&apos;), MODULAR(1, &apos;%&apos;), LEFT_BRACKET(2,</span><br><span class="line">			&apos;(&apos;), RIGHT_BRACKET(2, &apos;)&apos;);</span><br><span class="line"></span><br><span class="line">	public Integer prior;// 优先级</span><br><span class="line">	public Character operator;// 操作符</span><br><span class="line"></span><br><span class="line">	private OperatorsEnum(int prior, char operator) &#123;</span><br><span class="line">		this.prior = prior;</span><br><span class="line">		this.operator = operator;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return String.valueOf(operator);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">package cn.john.cal;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @ClassName: Cal</span><br><span class="line"> * </span><br><span class="line"> * @Description:</span><br><span class="line"> *               &lt;p&gt;</span><br><span class="line"> *               基于后缀表达式的简易计算器，目前支持个位数加、减、乘、除、模和括号六种运算。</span><br><span class="line"> *               &lt;p&gt;</span><br><span class="line"> *               中缀表达式-&gt;后缀表达式 操作符入栈</span><br><span class="line"> *               &lt;p&gt;</span><br><span class="line"> *               后缀表达式-&gt;计算值 操作数入栈</span><br><span class="line"> * </span><br><span class="line"> * @author: John</span><br><span class="line"> * </span><br><span class="line"> * @date: 2017年5月9日 下午7:55:58</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class Cal &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	</span><br><span class="line">	 * @Title: toPostFix</span><br><span class="line">	</span><br><span class="line">	 * @Description: 将中缀表达式转换为后缀表达式</span><br><span class="line">	</span><br><span class="line">	 * @param infix</span><br><span class="line">	 * @return</span><br><span class="line">	</span><br><span class="line">	 * @return: String</span><br><span class="line">	</span><br><span class="line">	 */</span><br><span class="line">	public String toPostFix(String infix) &#123;</span><br><span class="line">		// 算式字符数组</span><br><span class="line">		char[] ch = infix.trim().toCharArray();</span><br><span class="line">		LinkedList&lt;OperatorsEnum&gt; stack = new LinkedList&lt;OperatorsEnum&gt;();</span><br><span class="line">		StringBuilder sb = new StringBuilder();</span><br><span class="line"></span><br><span class="line">		OperatorsEnum op = null;</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; ch.length; i++) &#123;</span><br><span class="line">			// 对每个算式字符，检查它是不是操作符</span><br><span class="line">			if ((op = isOperator(ch[i])) == null) &#123;</span><br><span class="line">				sb.append(ch[i]);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				// 右括号</span><br><span class="line">				// 持续弹出栈顶元素直到遇到左括号，但是不输出左括号</span><br><span class="line">				if (op.equals(OperatorsEnum.RIGHT_BRACKET)) &#123;</span><br><span class="line">					// 如果不是左括号，持续弹出并输出</span><br><span class="line">					while (!stack.peek().equals(OperatorsEnum.LEFT_BRACKET)) &#123;</span><br><span class="line">						sb.append(stack.pop());</span><br><span class="line">					&#125;</span><br><span class="line">					// 此时栈顶元素为左括号，直接弹出，不输出</span><br><span class="line">					stack.pop();</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					// 非右括号</span><br><span class="line">					// 1、弹出并输出所有高优先级或者同等优先级，直到遇到低优先级或者左括号为止</span><br><span class="line">					// 上面的弹出语句有可能将栈弹空，检查stack的size避免NPE</span><br><span class="line">					while (stack.size() &gt; 0 &amp;&amp; stack.peek().prior &gt;= op.prior</span><br><span class="line">							&amp;&amp; !stack.peek().equals(OperatorsEnum.LEFT_BRACKET)) &#123;</span><br><span class="line">						sb.append(stack.pop());</span><br><span class="line">					&#125;</span><br><span class="line">					// 2、将当前操作符入栈</span><br><span class="line">					stack.push(op);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 弹出所有栈中剩余操作符</span><br><span class="line">		while (stack.size() &gt; 0) &#123;</span><br><span class="line">			sb.append(stack.pop());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	</span><br><span class="line">	 * @Title: calc</span><br><span class="line">	</span><br><span class="line">	 * @Description: 计算后缀表达式的值</span><br><span class="line">	</span><br><span class="line">	 * @param postfix</span><br><span class="line">	 * @return</span><br><span class="line">	</span><br><span class="line">	 * @return: double</span><br><span class="line">	</span><br><span class="line">	 */</span><br><span class="line">	public double calc(String postfix) &#123;</span><br><span class="line">		char[] ch = postfix.toCharArray();</span><br><span class="line">		LinkedList&lt;Double&gt; stack = new LinkedList&lt;Double&gt;();</span><br><span class="line">		OperatorsEnum op = null;</span><br><span class="line">		for (int i = 0; i &lt; ch.length; i++) &#123;</span><br><span class="line">			if ((op = isOperator(ch[i])) == null) &#123;</span><br><span class="line">				// 不是操作符，将当前数值入栈</span><br><span class="line">				stack.push(Double.parseDouble(String.valueOf(ch[i])));</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				// 是操作符，进行计算</span><br><span class="line">				double b = stack.pop();</span><br><span class="line">				double a = stack.pop();</span><br><span class="line">				switch (op) &#123;</span><br><span class="line">				case PLUS:</span><br><span class="line">					stack.push(a + b);</span><br><span class="line">					break;</span><br><span class="line">				case MINUS:</span><br><span class="line">					stack.push(a - b);</span><br><span class="line">					break;</span><br><span class="line">				case MULTIPLY:</span><br><span class="line">					stack.push(a * b);</span><br><span class="line">					break;</span><br><span class="line">				case DIVIDE:</span><br><span class="line">					stack.push(a / b);</span><br><span class="line">					break;</span><br><span class="line">				case MODULAR:</span><br><span class="line">					stack.push(a % b);</span><br><span class="line">					break;</span><br><span class="line">				default:</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return stack.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	</span><br><span class="line">	 * @Title: isOperator</span><br><span class="line">	</span><br><span class="line">	 * @Description: 判断字符是否为操作符</span><br><span class="line">	</span><br><span class="line">	 * @param ch</span><br><span class="line">	 * @return</span><br><span class="line">	</span><br><span class="line">	 * @return: OperatorsEnum</span><br><span class="line">	</span><br><span class="line">	 */</span><br><span class="line">	private OperatorsEnum isOperator(char ch) &#123;</span><br><span class="line">		for (OperatorsEnum op : OperatorsEnum.values()) &#123;</span><br><span class="line">			if (ch == op.operator) &#123;</span><br><span class="line">				return op;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	// test</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	</span><br><span class="line">	 * @Title: readEquation</span><br><span class="line">	</span><br><span class="line">	 * @Description: 终端输入算式</span><br><span class="line">	</span><br><span class="line">	 * @return</span><br><span class="line">	</span><br><span class="line">	 * @return: String</span><br><span class="line">	</span><br><span class="line">	 */</span><br><span class="line">	public String readEquation() &#123;</span><br><span class="line">		Scanner sc = new Scanner(System.in);</span><br><span class="line">		String equation = sc.nextLine();</span><br><span class="line">		sc.close();</span><br><span class="line">		return equation;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Cal c = new Cal();</span><br><span class="line">		System.out.println(&quot;Please input an equation,press ENTER to submit!&quot;);</span><br><span class="line">		String infix = c.readEquation();</span><br><span class="line">		String s = c.toPostFix(infix);</span><br><span class="line">		System.out.println(&quot;postfix: &quot; + s);</span><br><span class="line">		System.out.println(&quot;Result: &quot;+infix + &quot;=&quot; + c.calc(s));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/08/Java 基础知识总结--持续更新/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Old John">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/05/08/Java 基础知识总结--持续更新/" class="post-title-link" itemprop="url">Java 基础知识总结--持续更新</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-05-08 11:02:00" itemprop="dateCreated datePublished" datetime="2017-05-08T11:02:00+08:00">2017-05-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 16:24:51" itemprop="dateModified" datetime="2019-01-24T16:24:51+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java是OOP语言，所有的OOP语言都有三个特性：封装、多态、继承。</p>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>封装是一种将代码与它所处理的数据结合起来，而不被外界干扰滥用的程序设计机制。<br>在Java中，基本封装单元是<strong>类</strong>，数据即字段，代码即方法。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态是一种允许使用一个接口来访问一类动作的特性。<br>在Java中，多态的表现形式为：1、接口的实现；2、继承父类进行方法重写（override）；3、同一个类中进行方法的重载（overloaded）。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承是一个对象获得另一个对象的属性的过程。继承之所以重要，是因为它支持层级结构类的概念。</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>对象的类型，决定一类对象的外观和行为。一个类中可以设置<strong>两种</strong>类型的元素：<strong>字段</strong>和<strong>方法</strong>。<br>字段可以是任意类型的对象（基本类型和引用类型/ps：注意字段的初始化和局部变量初始化的区别）；方法由名称、参数、返回值和方法体构成，其中名称和参数列表合起来称为方法签名以用来唯一的标识一个方法。<br>当创建类时，就是在描述那个类的对象的外观和行为。</p>
<h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><p>一个类通过new新建了对象之后，数据存储空间才会分配，其方法和域才能被外界所使用。<br>static关键字用来解决以下两种情形：1、<strong>只想为某特定域分配单一的存储空间</strong>，而不去考虑究竟要创建多少对象，或者根本不需要创建对象。2、<strong>希望某个方法不与包含它的类任何对象关联在一起</strong>。即使没有创建对象，也可以使用该方法。</p>
<p>static{}(即static块)，会在类被加载的时候执行且仅会被执行一次，一般用来初始化静态变量和调用静态方法。</p>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>抽象方法是仅有方法声明但是没有方法体的方法。包含抽象方法的类称为抽象类。抽象类是介于类和接口的中庸之道。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口是一个<strong>完全抽象的类</strong>。一方面，一个接口表示：所有实现了该接口的类看起来都像这样，这建立了类与类之间通信的<strong>协议</strong>；<br>另一方面，接口也是其实现类的<strong>基类</strong>，类可以被向上转型为借口类型，它允许通过创建一个能够被向上转型为多种基类的类型，来实现某种类型多重继变种的特性。（一个实现了多种接口的类，其基类可以是其中任意一种。）<br>既然接口也是类，则满足类的基本特性：具有字段和方法。由于接口的协议特性，接口的字段和方法默认都是<strong>public</strong>的。其中字段还是<strong>static final</strong>的。<br><strong>接口支持多继承</strong>。如RunnableFuture接口。</p>
<h3 id="嵌套接口"><a href="#嵌套接口" class="headerlink" title="嵌套接口"></a>嵌套接口</h3><p>接口<strong>可以嵌套在类或者其他接口</strong>中。实际上是一种<strong>内部类</strong>。<br>由接口的协议特性，接口中的嵌套接口必须是public的。实现该外围接口无需实现嵌套接口。类中的嵌套接口可以是private的。</p>
<h1 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h1><h1 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h1><p>1、    子类可以继承父类的非private属性和方法，不包括构造函数。属性和方法均属于类的成员，构造方法不是成员。继承描述了is-a关系，描述了两个对象的属性和行为的相似性关联性。构造函数顾名思义是用来构造一个对象的，是用来为对象的初始化服务的，并不参与对象的属性和行为的描述。<br>2、    子类不能继承父类的private成员，但是如果父类有protected或者public方法可以访问父类private成员，子类可以通过这些方法访问private成员。<br>3、    子类可以拥有自己的属性和方法。继承描述了共性，也提供了特殊性的表示方法。<br>4、    子类可以用自己的方式实现父类的方法—方法的重写<br>5、    子类可以实现父类方法的不同版本—方法的重载</p>
<h1 id="对象初始化顺序"><a href="#对象初始化顺序" class="headerlink" title="对象初始化顺序"></a>对象初始化顺序</h1><p>父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数<br>当实例化子类对象时，首先要加载父类的class文件进内存，静态代码块是随着类的创建而执行，所以父类静态代码块最先被执行，子类class文件再被加载，同理静态代码块被先执行；实例化子类对象要先调用父类的构造方法，而调用父类构造方法前会先执行父类的非静态代码块</p>
<h1 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h1><p>方法的签名：指的是方法的组成结构。具体包括方法的名称和参数，涵盖参数的数量，类型以及出现的顺序，但是不包括方法的返回值类型、访问权限修饰符、抛出的异常</p>
<p>初步理解：重载和重写都是多态性的表现。重载是指的同一个方法名称，但是有不同的方法签名，存在于继承和同一个类中。重写是指方法签名以及返回类型不变，抛出的异常应是被重写方法的子类，但是方法的执行逻辑变了—子类修改了父类的实现逻辑，是为重写。</p>
<p>方法的重写（override）两同两小一大原则：<br>方法名相同，参数类型相同<br>子类返回类型小于等于父类方法返回类型，<br>子类抛出异常小于等于父类方法抛出异常，<br>子类访问权限大于等于父类方法访问权限。</p>
<h1 id="try-catch-finally-return"><a href="#try-catch-finally-return" class="headerlink" title="try catch finally return"></a>try catch finally return</h1><p>1、不管有木有出现异常，finally块中代码都会执行；<br>2、当try和catch中有return时，finally仍然会执行；<br>3、finally是在return语句执行之后，返回之前执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前就已经确定了；<br>4、finally中如果包含return，那么程序将在这里返回，而不是try或catch中的return返回，返回值就不是try或catch中保存的返回值了。<br>注意：<br>finally修改的基本类型是不影响返回结果的。（传值的）<br>修改list ,map,自定义类等引用类型时，是影响返回结果的。（传址的）对象也是传址的</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p><a href="https://www.cnblogs.com/dolphin0520/p/3811445.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3811445.html</a><br>内部类在外部类中，类比外部类的成员变量<br>内部类其实和类的属性没什么区别，只是在声明的时候必须是Outer.Inner a，就像int a 一样，至于静态内部类和非静态内部类new的时候有点区别</p>
<h1 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h1><p> 对应每个类的class文件，像是每个类的超级管理员。</p>
<h1 id="动态方法分配"><a href="#动态方法分配" class="headerlink" title="动态方法分配"></a>动态方法分配</h1><p>动态方法分配机制，通过该机制，对一个被重写方法的调用会在运行时解析，而不是编译时解析。是java实现运行时多态的机制。具体如：当通过超类引用调用被重写方法时，java会根据在调用发生时引用的对象的类型来判断所要执行的方法。 </p>
<h1 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h1><p>this关键字只能在方法内部使用，表示对“调用方法的那个对象”的<strong>引用</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">	int i;</span><br><span class="line">	int j;</span><br><span class="line">	public A(int i)&#123;&#125;</span><br><span class="line">	public A(int i,int j)&#123;</span><br><span class="line">	this(i);//调用构造器</span><br><span class="line">	this.j = j;//引用属性</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p><img src="http://img.blog.csdn.net/20170925153212340?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvam9obl9sdw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="equals-和"><a href="#equals-和" class="headerlink" title="equals()和=="></a>equals()和==</h1><p>equals()是Object的方法，==是关系操作符，关系操作符计算的结果是一个boolean结果。计算的是操作数的值之间的关系。<br>对于基本数据类型（不是对象），equals()无法使用，通过==直接比较值。<br>对于引用数据类型，<strong>==和Object对象</strong>的equals()方法都是比较的<strong>对象的引用</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object 的equals()方法：</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">        return (this == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想<strong>比较对象的内容，需要自己重写equals()方法</strong>。大部分java类库都实现了equals()方法，以便用来比较对象的内容，而不仅仅是引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">String 的equals()方法：</span><br><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">		//如果引用相同则两个String对象内容相同</span><br><span class="line">        if (this == anObject) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果引用不相同，则挨个比较两个字符串对象的字符（比较内容）</span><br><span class="line">        if (anObject instanceof String) &#123;</span><br><span class="line">            String anotherString = (String) anObject;</span><br><span class="line">            int n = value.length;</span><br><span class="line">            if (n == anotherString.value.length) &#123;</span><br><span class="line">                char v1[] = value;</span><br><span class="line">                char v2[] = anotherString.value;</span><br><span class="line">                int i = 0;</span><br><span class="line">                while (n-- != 0) &#123;</span><br><span class="line">                    if (v1[i] != v2[i])</span><br><span class="line">                            return false;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="静态内部类和内部类"><a href="#静态内部类和内部类" class="headerlink" title="静态内部类和内部类"></a>静态内部类和内部类</h1><p> 要想直接创建内部类的对象，必须先使用外部类的对象来创建该内部类对象。在拥有外部类对象之前是不可能创建内部类对象的，因为内部类对象会暗暗连接到创建它的外部类对象上去。<br> 静态内部类则没有这个限制，可以直接创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class A&#123;</span><br><span class="line">	public class B&#123;&#125;</span><br><span class="line">	public static class C&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">	A a = new A();</span><br><span class="line">	//这里不可以直接创建内部类B的对象</span><br><span class="line">	//A.B b = new B();</span><br><span class="line">	//正确方式，通过A的实例来创建</span><br><span class="line">	A.B b = a.new B();</span><br><span class="line">	//对于C，可以直接创建</span><br><span class="line">	A.C c = new C();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Java参数传递"><a href="#Java参数传递" class="headerlink" title="Java参数传递"></a>Java参数传递</h1><p><strong>Java中参数传递的都是值</strong>。<br>对于函数对参数的改变是否会影响原值的问题：</p>
<ul>
<li>值类型：传递值的拷贝，改变参数值不影响原值</li>
<li>引用类型：传递引用的拷贝，如果参数指向了不同的实例则参数引用和原引用不相等，如果改变的是实例本身，则参数和原引用相等</li>
</ul>
<h1 id="equals和hashcode"><a href="#equals和hashcode" class="headerlink" title="equals和hashcode"></a>equals和hashcode</h1><p>equals方法用来定义两个对象实例（注意不是引用）是否相等的规则，可以理解为判断两个对象实例是否是一模一样的实例。</p>
<p>hashcode方法主要用在哈希表中，对象通过hashcode方法算出对象的哈希值，再去哈希表中插入或者查找。我们知道计算hashcode时是可能存在碰撞情况的，也就是不同的对象（equals），hashcode可能是一样的；但是两个对象的hashcode不一样的话，那么这两个对象一定是不相等（equals）的。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>List<br><strong>ArrayList</strong>  数组 与System.arrayCopy<br><strong>LinkedList</strong>  带头尾节点的双向链表，可以作为<strong>双端队列和栈</strong>。</p>
<p>Map<br><strong>HashMap</strong><br><strong>LinkedHashMap</strong>  Entry带有前后节点的引用，带头结点的双向链表，保持插入顺序，或者在插入顺序的基础上再保持访问顺序-每次访问某个Entry，将该Entry移至链表尾部，成为最近最多使用节点（这里get方法和put方法都是如此，尤其是put方法中key已经存在了，同样会被移至链表尾部，因为recordAccess方法在HashMap中已经写在put方法里了）。启用访问顺序可以作为LRU链表使用，需要重写方法removeEldestEntry设定移除条件（如大小到了某个值），在条件达到时，即移除最近最少访问节点。</p>
<p>插入顺序还是访问顺序，最近最少访问节点都是链表的头结点，最近最多访问节点是链表尾节点。</p>
<p><strong>TreeMap</strong> 红黑树 二叉查找树 需要比较器<br><strong>WeakHashMap</strong><br><strong>ConcurrentHashMap</strong></p>
<p>Set<br><strong>HashSet</strong>   由HashMap支持<br><strong>LinkedHashSet</strong>   由LinkedHashMap支持，遍历有序<br><strong>TreeSet</strong> 由TreeMap支持，遍历有序</p>
<p>Queue<br><strong>PriorityQueue</strong>  优先队列，由数组和堆支持。堆序性质：树的根节点小于子节点。堆序性质的维护：在叶子节点插入，上滤保持堆序；在根节点删除，下滤保持堆序。<br>另外还有扩容操作，直接增加容量再复制数组即可。</p>
<p>主要设计模式：模板方法模式、迭代器模式</p>
<h1 id="并发包"><a href="#并发包" class="headerlink" title="并发包"></a>并发包</h1><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>AQS、ReentrantLock、ReentrantReadWriteLock、Lock、Condition、LockSupport、synchronized、volatile等</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>定义：Callable、Runnable、Thread、Future、FutureTask、ThreadLocal<br>执行：Executor、Executors、ExecutorService、ThreadPoolExecutor、ScheduledExecutorService<br>协同：ForkJoin、CountDownLatch、中断等</p>
<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><p>ConcurrentHashMap<br>阻塞队列：ArrayBlockingQueue  LinkedBlockingQueue PriorityQueue（等待通知模式）<br>非阻塞队列：ConcurrentLinkedQueue</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>可以将有状态的Bean转换为无状态的Bean，如spring中的DAO，数据库连接必须是线程私有的，无法共享，通过ThreadLocal Connection将连接线程私有化。<br>主要通过Thread类中的ThreadLocalMap发挥作用。每个线程都有自己的ThreadLocalMap，其key为ThreadLocal对象，value为设定的值。在调用ThreadLocal的get方法获取值时，都是去当前线程的ThreadLocalMap中获取。</p>
<p>ThreadLocalMap中的Entry是弱引用，其弱引用是key。如果某个线程一直不死（线程池），ThreadLocalMap中的Entry将永远得不到回收。通过将key作为弱引用，帮助GC（在set和get方法中都有处理弱引用失效的Entry流程，将他它们清理出map，避免内存泄漏）。</p>
<p>key的hashcode值时ThreadLocalMap中的static方法生成的，同一个应用中公用这一个方法生成hashcode。该map由循环数组支持，其处理hash碰撞的方法是线性探测法。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/25/SQL各种Join连接总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Old John">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/04/25/SQL各种Join连接总结/" class="post-title-link" itemprop="url">SQL各种Join总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-04-25 10:20:28" itemprop="dateCreated datePublished" datetime="2017-04-25T10:20:28+08:00">2017-04-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 17:15:43" itemprop="dateModified" datetime="2019-01-24T17:15:43+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>连接运算是<a href="http://baike.baidu.com/link?url=wMdfpPRrn4SWrSVJzJOXY0erJQWqoff26sxs781cB7bNpucENJ1hnmOC3Zltmpd6C0JxeDy6SMlD7MyoeHfBrqhpQ_bt0EtHZHdtLhRLmk-87G-4ouqYDtvLcdkAP1SU" target="_blank" rel="noopener">8种关系运算</a>中的一种。</p>
<p>五种JOIN方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.INNER JOIN or JOIN</span><br><span class="line">2.OUTER JOIN</span><br><span class="line">	2.1LEFT OUTER JOIN or LEFT JOIN</span><br><span class="line">	2.2RIGHT OUTER JOIN or RIGHT JOIN</span><br><span class="line">	2.3FULL OUTER JOIN or FULL JOIN</span><br><span class="line">3.NATURAL JOIN</span><br><span class="line">4.CROSS JOIN</span><br><span class="line">5.SELF JOIN</span><br><span class="line"></span><br><span class="line">PS:JOIN中的简写为语法糖，实际中写出来方便读一点而已</span><br></pre></td></tr></table></figure></p>
<p>两种连接条件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.Equi JOIN</span><br><span class="line">	1.1NATURAL</span><br><span class="line">	1.2USING(a,b)</span><br><span class="line">	1.3=</span><br><span class="line">	...</span><br><span class="line">2.Theta JOIN</span><br><span class="line">	2.1&gt;=</span><br><span class="line">	2.2&lt;=</span><br><span class="line">	2.3&gt;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">PS:USING(...)指定需要哪些列相等。ON则可以指定任意的连接条件(=,&gt;=,&lt;=,!=,&gt;,&lt;...)</span><br></pre></td></tr></table></figure></p>
<h1 id="JOIN-or-INNER-JOIN"><a href="#JOIN-or-INNER-JOIN" class="headerlink" title="JOIN or INNER JOIN"></a>JOIN or INNER JOIN</h1><p>返回两个表中同时满足条件的元组对，不满足的将被丢弃。</p>
<h1 id="OUTER-JOIN"><a href="#OUTER-JOIN" class="headerlink" title="OUTER JOIN"></a>OUTER JOIN</h1><h2 id="LEFT-OUTER-JOIN"><a href="#LEFT-OUTER-JOIN" class="headerlink" title="LEFT OUTER JOIN"></a>LEFT OUTER JOIN</h2><p>返回左表所有行以及右表满足条件的行，左表有值右表无值填充为null</p>
<h2 id="RIGHT-OUTER-JOIN"><a href="#RIGHT-OUTER-JOIN" class="headerlink" title="RIGHT OUTER JOIN"></a>RIGHT OUTER JOIN</h2><p>返回右表所有行以及左表满足条件的行，右表有值左表无值填充为null</p>
<h2 id="FULL-OUTER-JOIN"><a href="#FULL-OUTER-JOIN" class="headerlink" title="FULL OUTER JOIN"></a>FULL OUTER JOIN</h2><p>返回所有表的所有行，在满足条件的行之外，左表满足右表不满足或者相反，均填充null</p>
<h1 id="NATURAL-JOIN"><a href="#NATURAL-JOIN" class="headerlink" title="NATURAL JOIN"></a>NATURAL JOIN</h1><p>1、来自两个关系的元组对在共同属性上的值相同。（不限于一个共同属性，也可以是多个共同属性）<br>2、去掉重复的属性（列）。<br>3、列出属性的顺序：先是共同属性，然后是第一个关系的属性，最后是第二个关系的属性。</p>
<p>为了防止两个表有多个共同属性时natural join 会忽略部分需要的元组对，应使用join…using(…)，以指定需要哪些列相等<br>join…using(…)连接只能局限在指定的属性上</p>
<h1 id="CROSS-JOIN"><a href="#CROSS-JOIN" class="headerlink" title="CROSS JOIN"></a>CROSS JOIN</h1><p>返回笛卡儿积</p>
<h1 id="SELF-JOIN"><a href="#SELF-JOIN" class="headerlink" title="SELF JOIN"></a>SELF JOIN</h1><p>相当于A JOIN A</p>
<p>最后放一张图：<br><img src="http://img.blog.csdn.net/20170425111625395?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvam9obl9sdw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>参考：</p>
<blockquote>
<p><a href="http://stackoverflow.com/questions/565620/difference-between-join-and-inner-join" target="_blank" rel="noopener">http://stackoverflow.com/questions/565620/difference-between-join-and-inner-join</a><br><a href="http://stackoverflow.com/questions/3308122/how-do-i-decide-when-to-use-right-joins-left-joins-or-inner-joins-or-how-to-dete/3308153#3308153" target="_blank" rel="noopener">http://stackoverflow.com/questions/3308122/how-do-i-decide-when-to-use-right-joins-left-joins-or-inner-joins-or-how-to-dete/3308153#3308153</a><br><a href="http://stackoverflow.com/questions/17946221/sql-join-and-different-types-of-joins/17946222#17946222" target="_blank" rel="noopener">http://stackoverflow.com/questions/17946221/sql-join-and-different-types-of-joins/17946222#17946222</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.7.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>




  

  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  




  





  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
