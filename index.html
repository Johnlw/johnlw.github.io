<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="John What">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="John What">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="John What">






  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>John What</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">John What</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/15/Java String类相关/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John What">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/03/15/Java String类相关/" class="post-title-link" itemprop="url">Java String类相关</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-03-15 16:46:23" itemprop="dateCreated datePublished" datetime="2018-03-15T16:46:23+08:00">2018-03-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 20:44:20" itemprop="dateModified" datetime="2019-01-24T20:44:20+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="cookie技术"><a href="#cookie技术" class="headerlink" title="cookie技术"></a>cookie技术</h3><p>http协议是无状态的，服务器无法判断某一个简单http请求来自于谁。这里我们可以利用cookie技术，当一个用户第一次登录服务器时，http request中不带有cookie字段，服务器通过http response中set-cookie字段设置浏览器访问该网站的cookie，然后该用户第二次访问服务器时，由于服务器设置了cookie，浏览器会自动将关联该服务器的cookie中的内容添加在http request请求头中一并发给服务器，这时服务器通过cookie的内容就知道了这个请求来自于该用户。</p>
<p>cookie本质上是一些键值对组成的表，它还包括了过期时间，路径和域。</p>
<h3 id="session技术"><a href="#session技术" class="headerlink" title="session技术"></a>session技术</h3><p>服务器虽然可以简单的通过cookie技术识别用户，但是cookie本身安全性不好，容易被其他人读取。session技术是在服务端保存用户信息，而再向用户浏览器set-cookie时，设置一个sessionId，再次访问服务器时，通过sessionId来识别用户。</p>
<h3 id="session与cookie的关系"><a href="#session与cookie的关系" class="headerlink" title="session与cookie的关系"></a>session与cookie的关系</h3><p>两者都用于解决http协议无状态的问题，cookie基于客户端，session基于服务端，同时session依赖于cookie。因此，当浏览器禁用cookie的时候，session也将随之失效。</p>
<h3 id="session与cookie的生命周期"><a href="#session与cookie的生命周期" class="headerlink" title="session与cookie的生命周期"></a>session与cookie的生命周期</h3><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><ul>
<li>cookie在服务端返回http响应时可以设置有效时间，cookie在该时间范围内有效，过期即失效。cookie会持久化在硬盘上，即使浏览器关闭也可以再次读取，直至失效。</li>
<li>服务端返回时未设置有效时间，则cookie在浏览器关闭后即失效。<h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4></li>
<li>创建：在服务端调用HttpServletRequest.getSession(true)时为该用户创建session（ps:java服务端）</li>
<li>有效期：默认有效期30分钟，可以自行调整。</li>
<li>失效：1、session超时失效。2、调用invalidate()方法。3、服务器关闭或重启，这里如果session做了持久化，服务器重启之后依然可以从持久化的记录中重建session。<h3 id="session原理简述（tomcat）"><a href="#session原理简述（tomcat）" class="headerlink" title="session原理简述（tomcat）"></a>session原理简述（tomcat）</h3>这是tomcat下session包源码结构：<br><img src="http://johnlw.cn/blog_tomcat_session.png" alt="这里写图片描述"><br>session本身是一个接口，是servlet中HttpSession接口的外观模式，阅读session的标准实现类StandardSession源码，我们可以发现本质上其通过ConcurrentHashMap来保存存在其中的各属性值，记录了创建时间和上次访问时间用于表征生命周期状态等<br><img src="http://johnlw.cn/blog_session_code1.png" alt="这里写图片描述"></li>
</ul>
<p>对于整个web服务器来说，需要一个session容器来对session进行管理，这个容器对应的接口就是Manager接口，其抽象实现类ManagerBase中实现了对session生命周期的管理（创建、计时、销毁），其容器也是ConcurrentHashMap，其key值通常为jsessionId<br><img src="http://johnlw.cn/blog_session_code2.png" alt="这里写图片描述"></p>
<h3 id="负载均衡下session共享问题"><a href="#负载均衡下session共享问题" class="headerlink" title="负载均衡下session共享问题"></a>负载均衡下session共享问题</h3><ul>
<li>session保持：通过session保持，LB进行请求转发的时候保证每个客户端固定地访问到集群的同一台服务器。显然，session保持并不能保证真正的负载均衡</li>
<li>session复制：将每台服务器上的session信息复制给其他服务器，使得每台服务器都有一份session信息</li>
<li>session共享：将session信息放在统一的地方统一访问，将session信息放在redis或Memcached这类KV数据库里</li>
</ul>
<h3 id="cookie禁用问题"><a href="#cookie禁用问题" class="headerlink" title="cookie禁用问题"></a>cookie禁用问题</h3><p>可以用时URL重写，将sessionId附在url之后</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/15/JDK动态代理与CGLIB动态代理应用及源码解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John What">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/03/15/JDK动态代理与CGLIB动态代理应用及源码解析/" class="post-title-link" itemprop="url">JDK动态代理与CGLIB动态代理应用及源码解析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-03-15 13:40:44" itemprop="dateCreated datePublished" datetime="2018-03-15T13:40:44+08:00">2018-03-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 20:44:58" itemprop="dateModified" datetime="2019-01-24T20:44:58+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>代理模式中有三种角色：Subject抽象主题角色、RealSubject真实主题角色、Proxy代理主题角色。Subject描述了业务行为，RealSubject执行具体的业务逻辑，Proxy代理会拦截对RealSubject对象方法的调用，并在方法调用前后做预处理以及一些善后工作。</p>
<p>代理模式可以很好地在不侵入原代码的情况下，拓展原来的功能。</p>
<p>下图为Proxy模式的静态类图：<br><img src="http://johnlw.cn/blog_proxy_pattern.png" alt="这里写图片描述"><br>下图为Proxy模式的调用关系：<br><img src="http://johnlw.cn/blog_proxy_call.png" alt="这里写图片描述"></p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>静态代理由于硬编码，难以应对真实对象和调用方法灵活多变的情况，动态代理则对这些场景应付自如。</p>
<p>动态代理主要有两种实现方式：1、JDK自带的Proxy 2、CGLIB字节码生成库</p>
<h3 id="基于JDK的动态代理"><a href="#基于JDK的动态代理" class="headerlink" title="基于JDK的动态代理"></a>基于JDK的动态代理</h3><p>基于JDK的动态代理关键在于两个类：InvocationHandler和Proxy。<br>其主要实现逻辑是，由InvocationHandler定义方法执行前后的增强逻辑，由Proxy类去生成一个继承自Proxy并且实现了真实对象接口的新对象–代理对象，对该代理对象的方法调用经由InvocationHandler拦截，执行增强逻辑和调用真实对象执行业务逻辑。</p>
<p>下面我们先看一个例子：<br>定义接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">	public String getName(int id);</span><br><span class="line"></span><br><span class="line">	public Integer getAge(int id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义真实对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">	public UserServiceImpl() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String getName(int id) &#123;</span><br><span class="line">		System.out.println(&quot;---getName---&quot;);</span><br><span class="line">		return &quot;John&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Integer getAge(int id) &#123;</span><br><span class="line">		System.out.println(&quot;---getAge---&quot;);</span><br><span class="line">		return 10;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义InvocationHandler：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">	private Object target;</span><br><span class="line"></span><br><span class="line">	public MyInvocationHandler(Object target) &#123;</span><br><span class="line">		this.target = target;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">		if (method.getName().equals(&quot;getName&quot;)) &#123;</span><br><span class="line">			System.out.println(&quot;+++before get name+++&quot;);</span><br><span class="line">			Object res = method.invoke(target, args);</span><br><span class="line">			System.out.println(&quot;+++after get name+++&quot;);</span><br><span class="line">			return res;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			Object res = method.invoke(target, args);</span><br><span class="line">			return res;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line">		UserService us = new UserServiceImpl();</span><br><span class="line">		InvocationHandler ih = new MyInvocationHandler(us);</span><br><span class="line">		UserService usProxy = (UserService) Proxy.newProxyInstance(us.getClass().getClassLoader(),</span><br><span class="line">				us.getClass().getInterfaces(), ih);</span><br><span class="line">		System.out.println(usProxy.getName(1));</span><br><span class="line">		System.out.println(usProxy.getAge(1));</span><br><span class="line">		System.out.println(usProxy.getClass());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：<br><img src="http://johnlw.cn/blog_proxy_test_result.png" alt="这里写图片描述"></p>
<p>可以看到，对于getName方法的增强逻辑执行了。</p>
<p>下面我们从源码角度分析一下这个过程的实现原理，先看InvocationHandler：<br>InvocationHandler是一个接口，只有一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">       throws Throwable;</span><br></pre></td></tr></table></figure>
<p>在定义增强逻辑类时，需要实现该接口，并在invoke方法里实现增强逻辑和对真实对象方法的调用。对于invoke方法的三个参数，proxy表示代理对象，method表示真实对象的方法，args表示真实对象方法的参数，这里也可以看出对真实对象方法的调用是通过反射来实现的。</p>
<p>增强逻辑定义好了以后，我们需要一个代理对象来执行，先看如何产生这个代理对象。代理对象的产生是通过调用Proxy类的静态方法：newProxyInstance，以下源码分析部分篇幅原因仅截取部分代码片段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                          Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                          InvocationHandler h)</span><br><span class="line">        throws IllegalArgumentException</span><br><span class="line">        //该方法需要三个参数：ClassLoader确保返回的代理对象和真实对象由同一个类</span><br><span class="line">       </span><br><span class="line">        加载器加载，interfaces用于定义代理类应该实现的方法，</span><br><span class="line">        invocationHandler用于定义代理类的增强逻辑</span><br><span class="line">    &#123;</span><br><span class="line">        if (h == null) &#123;</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        final SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        if (sm != null) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Look up or generate the designated proxy class.</span><br><span class="line">         */</span><br><span class="line">         //这一行代码很关键，这里是获取代理对象Class对象，Proxy类内部维护了代理</span><br><span class="line">         //对象的缓存，如果缓存里有则直接返回，如果没有，则生成它</span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Invoke its constructor with the designated invocation handler.</span><br><span class="line">         */</span><br><span class="line">        try &#123;</span><br><span class="line">	        //由Class对象获取构造器</span><br><span class="line">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            final InvocationHandler ih = h;</span><br><span class="line">            if (sm != null &amp;&amp; ProxyAccessHelper.needsNewInstanceCheck(cl)) &#123;</span><br><span class="line">                // create proxy instance with doPrivilege as the proxy class may</span><br><span class="line">                // implement non-public interfaces that requires a special permission</span><br><span class="line">                return AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                    public Object run() &#123;</span><br><span class="line">                        return newInstance(cons, ih);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">	            //最后由构造器返回新的代理对象实例</span><br><span class="line">                return newInstance(cons, ih);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们看代理对象的Class对象是如何生成的，缓存逻辑略去不表，直接看没有缓存的情况，代理类Class对象由ProxyClassFactory工厂生成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static final class ProxyClassFactory</span><br><span class="line">        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        // prefix for all proxy class names</span><br><span class="line">        private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;</span><br><span class="line"></span><br><span class="line">        // next number to use for generation of unique proxy class names</span><br><span class="line">        private static final AtomicLong nextUniqueNumber = new AtomicLong();</span><br><span class="line">       //验证代码略去</span><br><span class="line">            /*</span><br><span class="line">             * Generate the specified proxy class.</span><br><span class="line">             */</span><br><span class="line">             //这里生成了代理对象二进制字节码流</span><br><span class="line">            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                proxyName, interfaces);</span><br><span class="line">            try &#123;</span><br><span class="line">	            //通过二进制字节码流加载代理类</span><br><span class="line">                return defineClass0(loader, proxyName,</span><br><span class="line">                                    proxyClassFile, 0, proxyClassFile.length);</span><br><span class="line">            &#125; catch (ClassFormatError e) &#123;</span><br><span class="line">                throw new IllegalArgumentException(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最终生成二进制字节码流用到了Sun的ProxyGenerator类，反编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] generateProxyClass(String s, Class aclass[])</span><br><span class="line">    &#123;</span><br><span class="line">        ProxyGenerator proxygenerator = new ProxyGenerator(s, aclass);</span><br><span class="line">        //该方法生成代理对象的二进制字节码流</span><br><span class="line">        byte abyte0[] = proxygenerator.generateClassFile();</span><br><span class="line">        //如果要保存该字节码文件，可以将其写到硬盘上，我们稍后分析</span><br><span class="line">        if(saveGeneratedFiles)</span><br><span class="line">            //保存文件部分略去</span><br><span class="line">        return abyte0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>具体生成源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">private byte[] generateClassFile() &#123;</span><br><span class="line">		addProxyMethod(hashCodeMethod, java / lang / Object);</span><br><span class="line">		addProxyMethod(equalsMethod, java / lang / Object);</span><br><span class="line">		addProxyMethod(toStringMethod, java / lang / Object);</span><br><span class="line">		for (int i = 0; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">			Method amethod[] = interfaces[i].getMethods();</span><br><span class="line">			for (int k = 0; k &lt; amethod.length; k++)</span><br><span class="line">				addProxyMethod(amethod[k], interfaces[i]);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		List list;</span><br><span class="line">		for (Iterator iterator = proxyMethods.values().iterator(); iterator.hasNext(); checkReturnTypes(list))</span><br><span class="line">			list = (List) iterator.next();</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			methods.add(generateConstructor());</span><br><span class="line">			for (Iterator iterator1 = proxyMethods.values().iterator(); iterator1.hasNext();) &#123;</span><br><span class="line">				List list1 = (List) iterator1.next();</span><br><span class="line">				Iterator iterator2 = list1.iterator();</span><br><span class="line">				while (iterator2.hasNext()) &#123;</span><br><span class="line">					ProxyMethod proxymethod = (ProxyMethod) iterator2.next();</span><br><span class="line">					fields.add(new FieldInfo(proxymethod.methodFieldName, &quot;Ljava/lang/reflect/Method;&quot;, 10));</span><br><span class="line">					methods.add(proxymethod.generateMethod());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			methods.add(generateStaticInitializer());</span><br><span class="line">		&#125; catch (IOException ioexception) &#123;</span><br><span class="line">			throw new InternalError(&quot;unexpected I/O Exception&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (methods.size() &gt; 65535)</span><br><span class="line">			throw new IllegalArgumentException(&quot;method limit exceeded&quot;);</span><br><span class="line">		if (fields.size() &gt; 65535)</span><br><span class="line">			throw new IllegalArgumentException(&quot;field limit exceeded&quot;);</span><br><span class="line">		cp.getClass(dotToSlash(className));</span><br><span class="line">		cp.getClass(&quot;java/lang/reflect/Proxy&quot;);</span><br><span class="line">		for (int j = 0; j &lt; interfaces.length; j++)</span><br><span class="line">			cp.getClass(dotToSlash(interfaces[j].getName()));</span><br><span class="line"></span><br><span class="line">		cp.setReadOnly();</span><br><span class="line">		ByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream();</span><br><span class="line">		DataOutputStream dataoutputstream = new DataOutputStream(bytearrayoutputstream);</span><br><span class="line">		try &#123;</span><br><span class="line">			dataoutputstream.writeInt(-889275714);</span><br><span class="line">			dataoutputstream.writeShort(0);</span><br><span class="line">			dataoutputstream.writeShort(49);</span><br><span class="line">			cp.write(dataoutputstream);</span><br><span class="line">			dataoutputstream.writeShort(49);</span><br><span class="line">			dataoutputstream.writeShort(cp.getClass(dotToSlash(className)));</span><br><span class="line">			dataoutputstream.writeShort(cp.getClass(&quot;java/lang/reflect/Proxy&quot;));</span><br><span class="line">			dataoutputstream.writeShort(interfaces.length);</span><br><span class="line">			for (int l = 0; l &lt; interfaces.length; l++)</span><br><span class="line">				dataoutputstream.writeShort(cp.getClass(dotToSlash(interfaces[l].getName())));</span><br><span class="line"></span><br><span class="line">			dataoutputstream.writeShort(fields.size());</span><br><span class="line">			FieldInfo fieldinfo;</span><br><span class="line">			for (Iterator iterator3 = fields.iterator(); iterator3.hasNext(); fieldinfo.write(dataoutputstream))</span><br><span class="line">				fieldinfo = (FieldInfo) iterator3.next();</span><br><span class="line"></span><br><span class="line">			dataoutputstream.writeShort(methods.size());</span><br><span class="line">			MethodInfo methodinfo;</span><br><span class="line">			for (Iterator iterator4 = methods.iterator(); iterator4.hasNext(); methodinfo.write(dataoutputstream))</span><br><span class="line">				methodinfo = (MethodInfo) iterator4.next();</span><br><span class="line"></span><br><span class="line">			dataoutputstream.writeShort(0);</span><br><span class="line">		&#125; catch (IOException ioexception1) &#123;</span><br><span class="line">			throw new InternalError(&quot;unexpected I/O Exception&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return bytearrayoutputstream.toByteArray();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，总结一下，Proxy类通过ProxyClassFactory生成了继承Proxy类并实现了真实对象接口的 $ProxyX代理对象的二进制字节码流，并加载该字节码返回代理对象Class对象，由该Class对象经反射得到构造器构造了代理对象的实例。<br>在源码中我们可以通过saveGeneratedFiles变量保存生成的class文件，我们反编译上面的示例生成的class文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public final class $Proxy0 extends Proxy implements UserService &#123;</span><br><span class="line"></span><br><span class="line">	private static Method m1;</span><br><span class="line">	private static Method m4;</span><br><span class="line">	private static Method m0;</span><br><span class="line">	private static Method m3;</span><br><span class="line">	private static Method m2;</span><br><span class="line"></span><br><span class="line">	public $Proxy0(InvocationHandler invocationhandler) &#123;</span><br><span class="line">		super(invocationhandler);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public final boolean equals(Object obj) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return ((Boolean) super.h.invoke(this, m1, new Object[]&#123;obj&#125;)).booleanValue();</span><br><span class="line">		&#125; catch (Error _ex) &#123;</span><br><span class="line">		&#125; catch (Throwable throwable) &#123;</span><br><span class="line">			throw new UndeclaredThrowableException(throwable);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">//这里是UserService接口的getAge方法，在代理对象$Proxy0上的调用被invocationHandler拦截，</span><br><span class="line">//经由其invoke方法调用（即我们之前定义的MyinvocationHandler的invoke方法），</span><br><span class="line">//留意invoke方法的参数，我们在MyinvocationHandler里定义invoke方法时并没有使用proxy参数，</span><br><span class="line">//这里proxy参数的位置传入了this变量，即代理对象本身。</span><br><span class="line">	public final Integer getAge(int i) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return (Integer) super.h.invoke(this, m4, new Object[]&#123;Integer.valueOf(i)&#125;);</span><br><span class="line">		&#125; catch (Error _ex) &#123;</span><br><span class="line">		&#125; catch (Throwable throwable) &#123;</span><br><span class="line">			throw new UndeclaredThrowableException(throwable);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public final int hashCode() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return ((Integer) super.h.invoke(this, m0, null)).intValue();</span><br><span class="line">		&#125; catch (Error _ex) &#123;</span><br><span class="line">		&#125; catch (Throwable throwable) &#123;</span><br><span class="line">			throw new UndeclaredThrowableException(throwable);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public final String getName(int i) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return (String) super.h.invoke(this, m3, new Object[]&#123;Integer.valueOf(i)&#125;);</span><br><span class="line">		&#125; catch (Error _ex) &#123;</span><br><span class="line">		&#125; catch (Throwable throwable) &#123;</span><br><span class="line">			throw new UndeclaredThrowableException(throwable);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public final String toString() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return (String) super.h.invoke(this, m2, null);</span><br><span class="line">		&#125; catch (Error _ex) &#123;</span><br><span class="line">		&#125; catch (Throwable throwable) &#123;</span><br><span class="line">			throw new UndeclaredThrowableException(throwable);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	static &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[]&#123;Class.forName(&quot;java.lang.Object&quot;)&#125;);</span><br><span class="line">			m4 = Class.forName(&quot;cn.john.test.dynamicProxy.UserService&quot;).getMethod(&quot;getAge&quot;, new Class[]&#123;Integer.TYPE&#125;);</span><br><span class="line">			m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">			m3 = Class.forName(&quot;cn.john.test.dynamicProxy.UserService&quot;).getMethod(&quot;getName&quot;, new Class[]&#123;Integer.TYPE&#125;);</span><br><span class="line">			m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">		&#125; catch (NoSuchMethodException nosuchmethodexception) &#123;</span><br><span class="line">			throw new NoSuchMethodError(nosuchmethodexception.getMessage());</span><br><span class="line">		&#125; catch (ClassNotFoundException classnotfoundexception) &#123;</span><br><span class="line">			throw new NoClassDefFoundError(classnotfoundexception.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于CGLIB的动态代理"><a href="#基于CGLIB的动态代理" class="headerlink" title="基于CGLIB的动态代理"></a>基于CGLIB的动态代理</h3><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceB &#123;</span><br><span class="line">	public String getName(int id) &#123;</span><br><span class="line">		System.out.println(&quot;---getName---&quot;);</span><br><span class="line">		return &quot;John&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	public Integer getAge(int id) &#123;</span><br><span class="line">		System.out.println(&quot;---getAge---&quot;);</span><br><span class="line">		return 10;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException, IOException &#123;</span><br><span class="line">	//将cglib生成的Class对象写成文件存入硬盘，后面反编译出来用以分析</span><br><span class="line">		System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;D:\\class&quot;);</span><br><span class="line">		UserServiceB us = new UserServiceB();</span><br><span class="line">		// 定义增强器</span><br><span class="line">		Enhancer en = new Enhancer();</span><br><span class="line">		// 定义要代理的对象</span><br><span class="line">		en.setSuperclass(us.getClass());</span><br><span class="line">		// 定义回调函数</span><br><span class="line">		en.setCallback(new MethodInterceptor() &#123;</span><br><span class="line">			//这里要理解intercept方法的几个参数代表的意思</span><br><span class="line">			//obj指的是代理类对象</span><br><span class="line">			//Method指的是 目标类中被拦截的方法</span><br><span class="line">			//args指的是 调用拦截方法所需的参数</span><br><span class="line">			//MethodProxy指的是用来调用目标类被拦截方法的方法，这个方法比反射更快</span><br><span class="line">			@Override</span><br><span class="line">			public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy)</span><br><span class="line">					throws Throwable &#123;</span><br><span class="line">				System.out.println(&quot;-----before-------&quot;);</span><br><span class="line">				//这里只能用invokeSuper，原因稍后解释</span><br><span class="line">				methodProxy.invokeSuper(obj, args);</span><br><span class="line">				System.out.println(&quot;-----after--------&quot;);</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;);</span><br><span class="line">		// 生成代理对象</span><br><span class="line">		UserServiceB usb = (UserServiceB) en.create();</span><br><span class="line">		// 在代理对象上调用方法</span><br><span class="line">		usb.getName(1);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="http://johnlw.cn/blog_cglib_test.png" alt="这里写图片描述"></p>
<p>同时生成了三个class文件：一个是代理类，一个是代理类的FastClass，一个是目标类的FastClass<br><img src="http://johnlw.cn/blog_cglib_classes.png" alt="这里写图片描述"></p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h6 id="代理类源码概览"><a href="#代理类源码概览" class="headerlink" title="代理类源码概览"></a>代理类源码概览</h6><p>从上面的示例代码中，我们知道通过cglib生成代理类只需要一个目标类和一个回调函数（增强逻辑），下面我们从在代理对象上调用getName()方法出发，一步一步分析cglib动态代理的实现原理。</p>
<p>先来看生成的代理对象Class文件反编译后的源码（代码很长，代理了Object中的finalize,equals, toString,hashCode,clone方法，这里仅留下getName()方法）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceB$$EnhancerByCGLIB$$a33459ad extends UserServiceB implements Factory &#123;</span><br><span class="line">	//cglib基于继承，可以看到代理类继承了目标类，并实现了Factory接口，Factory接口可以简化回调函数的变更</span><br><span class="line">	private boolean CGLIB$BOUND;</span><br><span class="line">	private static final ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">	private static final Callback[] CGLIB$STATIC_CALLBACKS;</span><br><span class="line">	private MethodInterceptor CGLIB$CALLBACK_0;//回调函数</span><br><span class="line">	private static final Method CGLIB$getName$0$Method;//目标类的getName方法</span><br><span class="line">	private static final MethodProxy CGLIB$getName$0$Proxy;//getName方法的代理方法</span><br><span class="line">	//初始化变量</span><br><span class="line">	static void CGLIB$STATICHOOK1() &#123;</span><br><span class="line">		CGLIB$THREAD_CALLBACKS = new ThreadLocal();</span><br><span class="line">		CGLIB$emptyArgs = new Object[0];</span><br><span class="line">		//代理类</span><br><span class="line">		Class class_ = Class.forName(&quot;cn.john.test.dynamicProxy.UserServiceB$$EnhancerByCGLIB$$a33459ad&quot;);</span><br><span class="line">		//目标类</span><br><span class="line">		Class class_2 = Class.forName(&quot;cn.john.test.dynamicProxy.UserServiceB&quot;);</span><br><span class="line">		Method[] arrmethod = ReflectUtils.findMethods(</span><br><span class="line">				(String[]) new String[]&#123;&quot;getName&quot;, &quot;(I)Ljava/lang/String;&quot;, &quot;getAge&quot;, &quot;(I)Ljava/lang/Integer;&quot;&#125;,</span><br><span class="line">				(Method[]) class_2.getDeclaredMethods());</span><br><span class="line">		//getName方法</span><br><span class="line">		CGLIB$getName$0$Method = arrmethod[0];</span><br><span class="line">		//建立更快的方法索引访问方式，这里通过目标类和代理类的Class对象和方法签名为这两个对象</span><br><span class="line">		//的所有方法都建立了索引，并提供了通过索引调用的方法。</span><br><span class="line">		//这里CGLIB$getName$0$Proxy提供在目标类（或者兼容类）上快速调用getName和在代理类上</span><br><span class="line">		//快速调用CGLIB$getName$0的功能</span><br><span class="line">		CGLIB$getName$0$Proxy = MethodProxy.create(class_2, class_, (String) &quot;(I)Ljava/lang/String;&quot;,</span><br><span class="line">				(String) &quot;getName&quot;, (String) &quot;CGLIB$getName$0&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//直接调用了目标类的方法，这个方法即用来执行目标类真实逻辑，通过索引调用来快速访问该方法</span><br><span class="line">	final String CGLIB$getName$0(int n) &#123;</span><br><span class="line">		return super.getName(n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//代理方法getName入口</span><br><span class="line">	public final String getName(int n) &#123;</span><br><span class="line">	//先获取回调函数</span><br><span class="line">		MethodInterceptor methodInterceptor = this.CGLIB$CALLBACK_0;</span><br><span class="line">		if (methodInterceptor == null) &#123;</span><br><span class="line">			UserServiceB$$EnhancerByCGLIB$$a33459ad.CGLIB$BIND_CALLBACKS((Object) this);</span><br><span class="line">			methodInterceptor = this.CGLIB$CALLBACK_0;</span><br><span class="line">		&#125;</span><br><span class="line">		//获取了回调函数之后</span><br><span class="line">		if (methodInterceptor != null) &#123;</span><br><span class="line">		//调用回调函数的拦截方法。</span><br><span class="line">		//注意这里传入的参数，代理类传入的this，被拦截的方法传入的是目标类对象的</span><br><span class="line">		//被拦截的方法，methodProxy传入的是getName方法的快速访问代理</span><br><span class="line">			return (String) methodInterceptor.intercept((Object) this, CGLIB$getName$0$Method,</span><br><span class="line">					new Object[]&#123;new Integer(n)&#125;, CGLIB$getName$0$Proxy);</span><br><span class="line">		&#125;</span><br><span class="line">		return super.getName(n);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public UserServiceB$$EnhancerByCGLIB$$a33459ad() &#123;</span><br><span class="line">		UserServiceB$$EnhancerByCGLIB$$a33459ad userServiceB$$EnhancerByCGLIB$$a33459ad = this;</span><br><span class="line">		UserServiceB$$EnhancerByCGLIB$$a33459ad.CGLIB$BIND_CALLBACKS((Object) userServiceB$$EnhancerByCGLIB$$a33459ad);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] arrcallback) &#123;</span><br><span class="line">		CGLIB$THREAD_CALLBACKS.set(arrcallback);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] arrcallback) &#123;</span><br><span class="line">		CGLIB$STATIC_CALLBACKS = arrcallback;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static final void CGLIB$BIND_CALLBACKS(Object object) &#123;</span><br><span class="line">		UserServiceB$$EnhancerByCGLIB$$a33459ad userServiceB$$EnhancerByCGLIB$$a33459ad = (UserServiceB$$EnhancerByCGLIB$$a33459ad) ((Object) object);</span><br><span class="line">		if (!userServiceB$$EnhancerByCGLIB$$a33459ad.CGLIB$BOUND) &#123;</span><br><span class="line">			userServiceB$$EnhancerByCGLIB$$a33459ad.CGLIB$BOUND = true;</span><br><span class="line">			Object t = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">			if (t != null || (v13465 = CGLIB$STATIC_CALLBACKS) != null) &#123;</span><br><span class="line">				userServiceB$$EnhancerByCGLIB$$a33459ad.CGLIB$CALLBACK_0 = (MethodInterceptor) ((Callback[]) t)[0];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	static &#123;</span><br><span class="line">		UserServiceB$$EnhancerByCGLIB$$a33459ad.CGLIB$STATICHOOK1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入回调函数后，跟JDK动态代理InvocationHandler一样，先执行前置增强逻辑，然后将目标类的真实逻辑。注意此处目标类的真实逻辑执行cglib的实现方式与JDK实现方式不同：JDK使用的是反射技术，而cglib则使用了FastClass构建方法索引+继承的方式访问目标类的方法。</p>
<h6 id="建立getName方法和CGLIB-getName0的索引"><a href="#建立getName方法和CGLIB-getName0的索引" class="headerlink" title="建立getName方法和CGLIB$getName0的索引"></a>建立getName方法和CGLIB$getName0的索引</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGLIB$getName$0$Proxy = MethodProxy.create(class_2, class_, (String) &quot;(I)Ljava/lang/String;&quot;,</span><br><span class="line">				(String) &quot;getName&quot;, (String) &quot;CGLIB$getName$0&quot;);</span><br><span class="line">				//注意这里class_2是目标类，class_是代理类</span><br></pre></td></tr></table></figure>
<p>我们截取MethodProxy类的部分代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">	private static class CreateInfo &#123;</span><br><span class="line">		Class c1;</span><br><span class="line">		Class c2;</span><br><span class="line">		NamingPolicy namingPolicy;</span><br><span class="line">		GeneratorStrategy strategy;</span><br><span class="line">		boolean attemptLoad;</span><br><span class="line"></span><br><span class="line">		public CreateInfo(Class c1, Class c2) &#123;</span><br><span class="line">			this.c1 = c1;</span><br><span class="line">			this.c2 = c2;</span><br><span class="line">			AbstractClassGenerator fromEnhancer = AbstractClassGenerator.getCurrent();</span><br><span class="line">			if (fromEnhancer != null) &#123;</span><br><span class="line">				this.namingPolicy = fromEnhancer.getNamingPolicy();</span><br><span class="line">				this.strategy = fromEnhancer.getStrategy();</span><br><span class="line">				this.attemptLoad = fromEnhancer.getAttemptLoad();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">//注意在MethodProxy类内部变量命名：这里目标类为1，而代理类变为了2</span><br><span class="line">	public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) &#123;</span><br><span class="line">	//准备数据阶段，目标类和代理类的Class对象，需要映射的方法签名，这里并不会</span><br><span class="line">	//触发实际上的建立方法索引</span><br><span class="line">		MethodProxy proxy = new MethodProxy();</span><br><span class="line">		proxy.sig1 = new Signature(name1, desc);</span><br><span class="line">		proxy.sig2 = new Signature(name2, desc);</span><br><span class="line">		proxy.createInfo = new CreateInfo(c1, c2);</span><br><span class="line">		return proxy;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际建立方法索引发生在回调函数中方法调用时（Lazyinit）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//MethodProxy类中的InvokeSuper</span><br><span class="line">public Object invokeSuper(Object obj, Object[] args) throws Throwable &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			this.init();//实际的方法索引在此时建立</span><br><span class="line">			FastClassInfo fci = this.fastClassInfo;</span><br><span class="line">			//在代理类FastClass对象上调用索引为i2的方法</span><br><span class="line">			return fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">		&#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">			throw e.getTargetException();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">//内部类FastClassInfo</span><br><span class="line">private static class FastClassInfo &#123;</span><br><span class="line">		FastClass f1;//目标类fc</span><br><span class="line">		FastClass f2;//代理类fc</span><br><span class="line">		int i1;//目标类getName方法索引</span><br><span class="line">		int i2;//代理类CGLIB$getName$0方法索引</span><br><span class="line"></span><br><span class="line">		private FastClassInfo() &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void init() &#123;</span><br><span class="line">		if (this.fastClassInfo == null) &#123;</span><br><span class="line">			Object object = this.initLock;</span><br><span class="line">			synchronized (object) &#123;</span><br><span class="line">				if (this.fastClassInfo == null) &#123;</span><br><span class="line">					CreateInfo ci = this.createInfo;</span><br><span class="line">					FastClassInfo fci = new FastClassInfo();</span><br><span class="line">					//这里通过字节码技术生成目标类和代理类的FastClass类的实例</span><br><span class="line">					//FastClass关键有两类方法：</span><br><span class="line">					//一类是getIndex方法，通过方法签名获取某方法的索引</span><br><span class="line">					//一类是invoke方法，通过方法的索引来找到方法并调用</span><br><span class="line">					fci.f1 = MethodProxy.helper(ci, ci.c1);//生成目标类的FastClass对象</span><br><span class="line">					fci.f2 = MethodProxy.helper(ci, ci.c2);//生成代理类的FastClass对象</span><br><span class="line">					//获取目标类和代理类的方法索引</span><br><span class="line">					fci.i1 = fci.f1.getIndex(this.sig1);</span><br><span class="line">					fci.i2 = fci.f2.getIndex(this.sig2);</span><br><span class="line">					this.fastClassInfo = fci;//至此，getName方法的索引建立、获取完毕</span><br><span class="line">					this.createInfo = null;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>回到示例上层代码：<code>methodProxy.invokeSuper(obj, args);</code>这里obj是代理对象，再看invokeSuper:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Object invokeSuper(Object obj, Object[] args) throws Throwable &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            init();//建立和获取索引</span><br><span class="line">            FastClassInfo fci = fastClassInfo;</span><br><span class="line">            //在obj即代理对象上调用索引为i2的方法</span><br><span class="line">            return fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            throw e.getTargetException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>现在我们反编译代理类的FastClass类看一下，<code>fci.f2.invoke(fci.i2, obj, args);</code>到底意味着什么。<br>代理类FastClass（部分代码）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceB$$EnhancerByCGLIB$$a33459ad$$FastClassByCGLIB$$9e4fc4c5 extends FastClass &#123;</span><br><span class="line">	public UserServiceB$$EnhancerByCGLIB$$a33459ad$$FastClassByCGLIB$$9e4fc4c5(Class class_) &#123;</span><br><span class="line">		super(class_);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int getIndex(Signature signature) &#123;</span><br><span class="line">		String string = signature.toString();</span><br><span class="line">		switch (string.hashCode()) &#123;</span><br><span class="line">			case -2024387448 : &#123;</span><br><span class="line">			//在上面的Init方法中我们已经获取了CGLIB$getName$0的索引，值为18</span><br><span class="line">				if (!string.equals(&quot;CGLIB$getName$0(I)Ljava/lang/String;&quot;))</span><br><span class="line">					break;</span><br><span class="line">				return 18;</span><br><span class="line">			&#125;</span><br><span class="line">			case 206620625 : &#123;</span><br><span class="line">				if (!string.equals(&quot;getName(I)Ljava/lang/String;&quot;))</span><br><span class="line">					break;</span><br><span class="line">				return 3;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">//在代理对象上调用索引为18的方法</span><br><span class="line">	public Object invoke(int n, Object object, Object[] arrobject) throws InvocationTargetException &#123;</span><br><span class="line">		UserServiceB$$EnhancerByCGLIB$$a33459ad userServiceB$$EnhancerByCGLIB$$a33459ad = (UserServiceB$$EnhancerByCGLIB$$a33459ad) ((Object) object);</span><br><span class="line">		try &#123;</span><br><span class="line">			switch (n) &#123;</span><br><span class="line">				case 3 : &#123;</span><br><span class="line">					return userServiceB$$EnhancerByCGLIB$$a33459ad.getName(((Number) arrobject[0]).intValue());</span><br><span class="line">				&#125;</span><br><span class="line">				//在代理对象上调用了CGLIB$getName$0方法，回到代理类源码，它调用super.getName，即目标类的真实逻辑</span><br><span class="line">				case 18 : &#123;</span><br><span class="line">					return userServiceB$$EnhancerByCGLIB$$a33459ad.CGLIB$getName$0(((Number) arrobject[0]).intValue());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (Throwable v1) &#123;</span><br><span class="line">			throw new InvocationTargetException(v1);</span><br><span class="line">		&#125;</span><br><span class="line">		throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们来回答一下为什么示例代码中不能调用invoke，而是只能调用invokeSuper。invoke代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object obj, Object[] args) throws Throwable &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            init();</span><br><span class="line">            FastClassInfo fci = fastClassInfo;</span><br><span class="line">            //因为在回调函数中obj传入的代理对象，这里实际上是在代理对象上调用</span><br><span class="line">            //getName方法，将陷入无限递归，直至栈溢出</span><br><span class="line">            return fci.f1.invoke(fci.i1, obj, args);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            throw e.getTargetException();</span><br><span class="line">        &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            if (fastClassInfo.i1 &lt; 0)</span><br><span class="line">                throw new IllegalArgumentException(&quot;Protected method: &quot; + sig1);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:center">机制</th>
<th>回调方式</th>
<th>适用场景</th>
<th>效率</th>
</tr>
</thead>
<tbody>
<tr>
<td>JDK动态代理</td>
<td style="text-align:center">委托机制，代理类和目标类都实现了同样的接口，InvocationHandler持有目标类，代理类委托InvocationHandler去调用目标类的原始方法</td>
<td>反射</td>
<td>目标类是接口类</td>
<td>效率瓶颈在反射调用稍慢</td>
</tr>
<tr>
<td>CGLIB动态代理</td>
<td style="text-align:center">继承机制，代理类继承了目标类并重写了目标方法，通过回调函数MethodInterceptor调用父类方法执行原始逻辑</td>
<td>通过FastClass方法索引调用</td>
<td>非接口类，非final类，非final方法</td>
<td>第一次调用因为要生成多个Class对象较JDK方式慢，多次调用因为有方法索引较反射方式快，如果方法过多switch case过多其效率还需测试</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="http://ifeve.com/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%A3%E7%90%86%E4%B8%8Ecglib%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" target="_blank" rel="noopener">http://ifeve.com/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%A3%E7%90%86%E4%B8%8Ecglib%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</a><br><a href="https://www.jianshu.com/p/9a61af393e41?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">https://www.jianshu.com/p/9a61af393e41?from=timeline&amp;isappinstalled=0</a><br><a href="https://www.jianshu.com/p/13aa63e1ac95" target="_blank" rel="noopener">https://www.jianshu.com/p/13aa63e1ac95</a><br><a href="https://www.cnblogs.com/cruze/p/3865180.html" target="_blank" rel="noopener">https://www.cnblogs.com/cruze/p/3865180.html</a><br>spring技术内幕</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/13/Session与Cookie/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John What">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/03/13/Session与Cookie/" class="post-title-link" itemprop="url">Session与Cookie</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-03-13 10:46:59" itemprop="dateCreated datePublished" datetime="2018-03-13T10:46:59+08:00">2018-03-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 20:32:03" itemprop="dateModified" datetime="2019-01-24T20:32:03+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="cookie技术"><a href="#cookie技术" class="headerlink" title="cookie技术"></a>cookie技术</h3><p>http协议是无状态的，服务器无法判断某一个简单http请求来自于谁。这里我们可以利用cookie技术，当一个用户第一次登录服务器时，http request中不带有cookie字段，服务器通过http response中set-cookie字段设置浏览器访问该网站的cookie，然后该用户第二次访问服务器时，由于服务器设置了cookie，浏览器会自动将关联该服务器的cookie中的内容添加在http request请求头中一并发给服务器，这时服务器通过cookie的内容就知道了这个请求来自于该用户。</p>
<p>cookie本质上是一些键值对组成的表，它还包括了过期时间，路径和域。</p>
<h3 id="session技术"><a href="#session技术" class="headerlink" title="session技术"></a>session技术</h3><p>服务器虽然可以简单的通过cookie技术识别用户，但是cookie本身安全性不好，容易被其他人读取。session技术是在服务端保存用户信息，而再向用户浏览器set-cookie时，设置一个sessionId，再次访问服务器时，通过sessionId来识别用户。</p>
<h3 id="session与cookie的关系"><a href="#session与cookie的关系" class="headerlink" title="session与cookie的关系"></a>session与cookie的关系</h3><p>两者都用于解决http协议无状态的问题，cookie基于客户端，session基于服务端，同时session依赖于cookie。因此，当浏览器禁用cookie的时候，session也将随之失效。</p>
<h3 id="session与cookie的生命周期"><a href="#session与cookie的生命周期" class="headerlink" title="session与cookie的生命周期"></a>session与cookie的生命周期</h3><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><ul>
<li>cookie在服务端返回http响应时可以设置有效时间，cookie在该时间范围内有效，过期即失效。cookie会持久化在硬盘上，即使浏览器关闭也可以再次读取，直至失效。</li>
<li>服务端返回时未设置有效时间，则cookie在浏览器关闭后即失效。<h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4></li>
<li>创建：在服务端调用HttpServletRequest.getSession(true)时为该用户创建session（ps:java服务端）</li>
<li>有效期：默认有效期30分钟，可以自行调整。</li>
<li>失效：1、session超时失效。2、调用invalidate()方法。3、服务器关闭或重启，这里如果session做了持久化，服务器重启之后依然可以从持久化的记录中重建session。<h3 id="session原理简述（tomcat）"><a href="#session原理简述（tomcat）" class="headerlink" title="session原理简述（tomcat）"></a>session原理简述（tomcat）</h3>这是tomcat下session包源码结构：<br><img src="http://johnlw.cn/blog_tomcat_session.png" alt="这里写图片描述"><br>session本身是一个接口，是servlet中HttpSession接口的外观模式，阅读session的标准实现类StandardSession源码，我们可以发现本质上其通过ConcurrentHashMap来保存存在其中的各属性值，记录了创建时间和上次访问时间用于表征生命周期状态等<br><img src="http://johnlw.cn/blog_session_code1.png" alt="这里写图片描述"></li>
</ul>
<p>对于整个web服务器来说，需要一个session容器来对session进行管理，这个容器对应的接口就是Manager接口，其抽象实现类ManagerBase中实现了对session生命周期的管理（创建、计时、销毁），其容器也是ConcurrentHashMap，其key值通常为jsessionId<br><img src="http://johnlw.cn/blog_session_code2.png" alt="这里写图片描述"></p>
<h3 id="负载均衡下session共享问题"><a href="#负载均衡下session共享问题" class="headerlink" title="负载均衡下session共享问题"></a>负载均衡下session共享问题</h3><ul>
<li>session保持：通过session保持，LB进行请求转发的时候保证每个客户端固定地访问到集群的同一台服务器。显然，session保持并不能保证真正的负载均衡</li>
<li>session复制：将每台服务器上的session信息复制给其他服务器，使得每台服务器都有一份session信息</li>
<li>session共享：将session信息放在统一的地方统一访问，将session信息放在redis或Memcached这类KV数据库里</li>
</ul>
<h3 id="cookie禁用问题"><a href="#cookie禁用问题" class="headerlink" title="cookie禁用问题"></a>cookie禁用问题</h3><p>可以用时URL重写，将sessionId附在url之后</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/28/单例模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John What">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/02/28/单例模式/" class="post-title-link" itemprop="url">单例模式</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-02-28 16:03:51" itemprop="dateCreated datePublished" datetime="2018-02-28T16:03:51+08:00">2018-02-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 20:25:05" itemprop="dateModified" datetime="2019-01-24T20:25:05+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="单例模式定义"><a href="#单例模式定义" class="headerlink" title="单例模式定义"></a>单例模式定义</h3><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p>
<h3 id="单例模式优缺点"><a href="#单例模式优缺点" class="headerlink" title="单例模式优缺点"></a>单例模式优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>在内存中只有一个实例，节约内存，减少性能开销。当一个对象的产生需要占用较多资源时（如文件、读取配置文件等），采用单例模式可有效节约资源。</li>
<li>单例对象可以作为全局访问点，优化和共享全局资源访问。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>单例模式要求自行实例化，因此单例模式一般没有接口，拓展性不好。<h3 id="单例模式使用场景"><a href="#单例模式使用场景" class="headerlink" title="单例模式使用场景"></a>单例模式使用场景</h3></li>
<li>要求生成唯一序列号的场景</li>
<li>在整个项目中需要一个共享访问点或共享资源</li>
<li>创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源</li>
<li>需要定义大量的静态变量和静态方法的场景</li>
</ul>
<h3 id="单例模式代码形式"><a href="#单例模式代码形式" class="headerlink" title="单例模式代码形式"></a>单例模式代码形式</h3><h4 id="饿汉形式"><a href="#饿汉形式" class="headerlink" title="饿汉形式"></a>饿汉形式</h4><pre><code>public class Singleton{
      private static Singleton instance = new Singleton();//在类加载时即进行创建
      private Singleton(){}
      public static Singleton newInstance(){
            return instance;
      }
}
</code></pre><p>饿汉形式中该对象在类加载的时候就完成了对象的创建，不存在线程安全问题。当对象占用内存小而且初始化后很快就会被用到时，饿汉形式很适用；但是如果这个对象并不急着用或者根本没有用到，该对象还是会被创建，如果该对象占用的内存空间较大，则造成了系统资源的浪费。</p>
<h4 id="懒汉形式"><a href="#懒汉形式" class="headerlink" title="懒汉形式"></a>懒汉形式</h4><pre><code>public class Singleton{
      private static Singleton instance = null;
      private Singleton(){}
      public static Singleton newInstance(){
             if(instance == null){
                   instance =  new Singleton();
             }
             return instance;
      }
}
</code></pre><p>懒汉形式中该对象时在需要的时候才去创建，即按需使用，在单例使用次数少、占用资源多的场景下比较适用。但是懒汉形式并不是线程安全的，当有多个线程同时调用newInstance方法时，可能会创建多个实例。</p>
<h4 id="线程安全的懒汉形式"><a href="#线程安全的懒汉形式" class="headerlink" title="线程安全的懒汉形式"></a>线程安全的懒汉形式</h4><pre><code>public class Singleton{
      private static Singleton instance = null;
      private Singleton(){}
      public static synchronized Singleton newInstance(){//使用synchronized关键字同步
             if(instance == null){
                   instance =  new Singleton();
             }
             return instance;
      }
}
</code></pre><p>这种形式下，线程每次调用newInstance方法都会先获取对象锁，然后再执行方法体，在高并发情况下，对象锁有可能升级为重量级锁，带来一定的性能问题。</p>
<h4 id="一种看起来可行的改进方式–双重检查锁定形式"><a href="#一种看起来可行的改进方式–双重检查锁定形式" class="headerlink" title="一种看起来可行的改进方式–双重检查锁定形式"></a>一种看起来可行的改进方式–双重检查锁定形式</h4><p>既然存在性能问题，我们将代码稍加改进：</p>
<pre><code>public class Singleton{
      private static Singleton instance = null;
      private Singleton(){}
      public static Singleton newInstance(){
             if(instance == null){
                  synchronized(Singleton.class){
                        if(instance == null){
                            instance =  new Singleton();
                        }                  
                  }                                 
             }
             return instance;
       }
}
</code></pre><p>在这种形式的代码下，只要对象被线程安全的创建成功，将不会在存在性能问题。然而既然是“看起来可行的”办法，那么一定有什么隐患。</p>
<h4 id="可靠的改进方式–volatile"><a href="#可靠的改进方式–volatile" class="headerlink" title="可靠的改进方式–volatile"></a>可靠的改进方式–volatile</h4><p>上面的双重检查锁定形式不可靠的地方在于它并不能保证线程安全，根本原因在于<code>instance = new Singleton();</code> 这一行代码可以分为如下三行伪代码：</p>
<pre><code>memory = allocate();//1.分配内存
initInstance(memory);//2.初始化
instance = memory;3.设置引用指向内存地址
</code></pre><p>我们知道在java代码的各级编译过程中都存在执行重排序的情况，如果上述代码中2和3被重排序，3先于2执行，并不违反单线程as-if-serial语义和多线程happens-before语义，再如果在2执行之前发生线程切换，另外一个线程在判断instance变量是否为Null时将返回false，并返回Instance，然而此时instance对应的内存区域并没有被初始化为Singleton对象。</p>
<p>那么我们应该如何处理这种情况呢？很简单，禁止<code>instance = new Singleton();</code>这行代码指令重排序，为此我们给instance变量引入happens-before语义限制—-就是用<code>volatile</code>关键字修饰instance变量。可靠的改进方式：</p>
<pre><code>public class Singleton{
      private static volatile Singleton instance = null;
      private Singleton(){}
      public static Singleton newInstance(){
             if(instance == null){
                  synchronized(Singleton.class){
                        if(instance == null){
                            instance =  new Singleton();
                        }                  
                  }                                 
             }
             return instance;
       }
}
</code></pre><h4 id="静态内部类形式"><a href="#静态内部类形式" class="headerlink" title="静态内部类形式"></a>静态内部类形式</h4><pre><code>public class Singleton{
    private static class SingletonHolder{
        public static Singleton instance = new Singleton();
    }
    public static Singleton newInstance(){
        return SingletonHolder.instance;
    }
}
</code></pre><p>在这种形式中，巧妙地利用的jvm的类加载机制，实现了线程安全的懒汉式实例化。<br>当线程调用newInstance方法时，会触发静态内部类SingletonHolder的加载和初始化，这里不存在线程安全问题；同时当没有线程调用newInstance方法时，静态内部类将不会被加载。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>由上面的分析可知，<strong>静态内部类形式</strong>和<strong>volatile关键字改进的双重检查锁定形式</strong>最能称得上是单例模式的最佳实践。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/24/Java并发机制（4）--AQS、ReentrantLock、ReentrantReadWriteLock源码分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John What">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/11/24/Java并发机制（4）--AQS、ReentrantLock、ReentrantReadWriteLock源码分析/" class="post-title-link" itemprop="url">Java并发机制（4）--AQS、ReentrantLock、ReentrantReadWriteLock源码分析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-11-24 16:20:31" itemprop="dateCreated datePublished" datetime="2017-11-24T16:20:31+08:00">2017-11-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 20:13:28" itemprop="dateModified" datetime="2019-01-24T20:13:28+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>锁是用来控制多个线程访问共享资源的工具，Java中有两种锁，一种是jvm层面的synchronized关键字，一种是JUC的Lock接口的实现类。<br>Lock接口对比synchronized关键字需要显示的获取/释放锁，虽然丧失了一定的便捷性，但是提供了synchronized关键字所不具备的获取/释放锁的灵活性、可中断获取锁、超时获取锁、非阻塞获取锁（trylock）、以及多个条件变量。</p>
<p>队列同步器（AQS），是用来构建锁和其他同步组件的基础框架，它提供了自动管理同步状态、线程的阻塞/唤醒、排队、条件变量以及监控五个方面的通用结构。AQS的设计模式基于模板方法模式，主要使用方式为继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，相当于子类同步器将同步的管理委托给AQS。</p>
<p>本文将沿着锁的获取到释放这个过程深入到AQS的源码实现。</p>
<h1 id="进一步认识锁"><a href="#进一步认识锁" class="headerlink" title="进一步认识锁"></a>进一步认识锁</h1><ol>
<li>公平/非公平。<br>锁按照获取策略可以分为公平锁和非公平锁。公平锁即要获取锁的线程都要按先来后到的顺序排队。非公平锁即在条件允许的情况下，谁竞争成功则谁获取到锁，获取失败的线程排队。</li>
<li>共享/排他<br>按照对于共享资源的访问模式，锁可以分为共享锁和排他锁。当多个线程都是读操作时，对共享资源内容不会修改，可以安全的并发访问，使用共享锁可以提高系统吞吐量。当多个线程中含有写操作时，会修改共享资源的内容，必须要采用排他模式保证共享资源的线程安全。</li>
<li>可重入锁<br>也叫递归锁。已经获取锁的线程在执行过程中可以不用竞争直接继续获取锁，只需在同步状态中记录索取的次数即可。可重入锁提高效率的同时，也可以有效避免死锁的发生。</li>
</ol>
<p>由之前的文章我们可知synchronized关键字提供的是非公平的、排他、可重入的锁。由AQS框架支撑的可重入锁ReentrantLock可以选择公平性，ReentrantReadWriteLock可以选择公平性、共享性。这里就可以体现出Lock接口下的锁的灵活之处。</p>
<p>这里有个线程饥饿的问题，就是当获取策略为非公平，共享锁和排他锁共存的情况，有可能造成排他锁线程长期饥饿状态得不到运行的情况。需要在排队时做出一定的限制，保证排他锁也有机会获取锁。</p>
<hr>
<h1 id="初识AQS"><a href="#初识AQS" class="headerlink" title="初识AQS"></a>初识AQS</h1><p>AQS主要提供了同步状态的管理、线程的阻塞/唤醒、排队、条件变量、监控五个方面的功能。</p>
<h3 id="同步状态的管理"><a href="#同步状态的管理" class="headerlink" title="同步状态的管理"></a>同步状态的管理</h3><p>AQS有一个volatile修饰的int变量state用于表示同步状态，在前面的文章我们讲解过volatile关键字的作用。同时提供了三个子类可访问的getState()，setState(int newState)，compareAndSetState(int expect, int update)的方法来访问和修改同步状态。<br>线程获取同步锁的策略由抽象方法tryAcquire(int arg)，tryRelease(int arg)，tryAcquireShared(int arg)，tryReleaseShared(int arg)描述，交由子类自己实现。这里AQS将操作和策略解耦，AQS本身并不关心子类怎么定义获取，怎么定义获取成功与失败，AQS关心的是当线程获取失败后如何处理（阻塞/唤醒、排队等），将获取策略解耦交给子类可以借以实现更复杂更灵活的同步方案（如排他模式下的公平锁和非公平锁ReentrantLock，共享模式下的ReentrantReadWriteLock等。）</p>
<h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><p>AQS内部维护了一个的带头尾引用的双链表用以构成一个FIFO的类CLH队列，队列中的节点类型由内部类Node表示。Node节点含有等待线程的引用、Node是共享/排他型节点、Node的状态、前后Node的引用等信息。head节点中的线程为当前队列中获取到锁的线程。<br>当线程竞争共享资源失败后，AQS将用该线程构建Node，并将其入队。</p>
<h3 id="阻塞与唤醒"><a href="#阻塞与唤醒" class="headerlink" title="阻塞与唤醒"></a>阻塞与唤醒</h3><p>线程在获取资源失败后在AQS中入队，该线程即将阻塞以释放CPU，这里Node节点的状态信息将发挥关键作用。<br>|waitStatus 节点状态|意义|<br>|-|-|<br>|CANCELLED|值为1，在线程在排队过程中出现了超时或者中断时，该线程将被取消，此时该节点状态将被置为1|<br>|SIGNAL|值为-1，由后继节点设置，当后继节点将当前节点状态设置为-1后，后继节点进入阻塞态；当前节点如果释放了资源或者被取消，将会通知后继节点（唤醒它）|<br>|CONDITION|值为-2，当节点在条件变量上等待时，节点的状态为CONDITION|<br>|PROPAGATE|值为-3，用于共享模式，表示下一次共享式同步状态将会无条件地被传播下去|<br>|INITIAL|值为0，初始状态|</p>
<p>线程入队后，检查前驱节点是否被取消，如果被取消则向前进直到找到未取消的前驱节点，将该前驱节点的状态设置为SIGNAL，然后进入阻塞态。<br>head节点为队列中当前占用资源的线程，该线程释放资源时，将唤醒后继节点竞争锁。<br>这类似等待/通知模式，这种方式避免了自旋主动查询浪费CPU时间。</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量常与互斥量一起使用，在条件变量上的等待需要先获取互斥量。AQS的等待/通知机制由内部类ConditionObject支持。ConditionObject实现了Condition接口，内部维护了一个带有首尾引用的FIFO单链表。节点类型依然为Node。<br>当有线程在某个ConditionObject上等待（调用Condition.await()）时，那么该线程首先将释放锁，然后构造新的Node类型节点入队并进入阻塞状态。<br>调用ConditionObject对象上的signal()方法，先将首节点移至同步等待队列队尾，然后唤醒该线程，进而加入到同步状态的竞争中。</p>
<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>AQS提供了一些用于监控当前同步队列和条件队列的方法。如getQueueLength()，getQueuedThreads()，getExclusiveQueuedThreads()，getSharedQueuedThreads()，getWaitQueueLength(ConditionObject condition)等，便于对同步器的竞争状态有个估计（AQS中的队列一直在变化，监测方法只能返回一个估计值）。</p>
<hr>
<p>锁有两个基本的操作，一个是锁的获取，一个是锁的释放。</p>
<p>AQS支持不可中断、可中断、超时三种类型的获取锁，后两者均基于不可中断的获取模式；同时AQS还支持共享锁和排他锁，这里我们先以不可中断方式、排他模式进行分析。</p>
<h1 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h1><h3 id="获取过程"><a href="#获取过程" class="headerlink" title="获取过程"></a>获取过程</h3><p>AQS的acquire方法：</p>
<pre><code>public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre><p>代码逻辑：先尝试获取（此方法由子类自己定义），如果尝试失败了，则新增节点（addWaiter），再进行排队（acquireQueued）。新增节点是先将当前线程构建新节点，然后CAS设置tail节点入队。重点在入队之后的acquireQueued方法：</p>
<pre><code>final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
        //进入队列后进入循环
            final Node p = node.predecessor();
            //当前驱节点为head节点时，当前节点具有竞争资格，如果竞争成功，则将当前节点设置为头结点，并从循环中退出。也就是说，队列中只有头结点是占有锁的。
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            //如果前驱节点不是head节点，或者竞争失败，看下面的shouldParkAfterFailedAcquire(p, node)方法
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    //如果前驱节点状态是SIGNAL，则表示前驱节点在释放资源时会通知自己，这时候返回true，由parkAndCheckInterrupt()方法阻塞线程。
    if (ws == Node.SIGNAL)
        /*
         * This node has already set status asking a release
         * to signal it, so it can safely park.
         */
        return true;
        //如果前驱节点状态大于0，只可能是节点已经被取消，则不断前进直到找到未取消的节点
    if (ws &gt; 0) {
        /*
         * Predecessor was cancelled. Skip over predecessors and
         * indicate retry.
         */
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else {
    //除去上面两种状态，现在只可能是0或者PROPAGATE状态了，因为shouldParkAfterFailedAcquire是获取失败或者没资格获取后调用的方法，我们需要将前驱节点的状态CAS设置为SIGNAL，以便当资源可用时通知自己去竞争。
        /*
         * waitStatus must be 0 or PROPAGATE.  Indicate that we
         * need a signal, but don&apos;t park yet.  Caller will need to
         * retry to make sure it cannot acquire before parking.
         */
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
</code></pre><p>这里我们可以看到每个新节点入队后，都会在前驱节点的SIGNAL状态上阻塞。另外在当自己有了竞争资格但是竞争失败的情况下，如果头结点状态不为SIGNAL，自己可能还有几次的循环请求的机会。</p>
<p>至此，不可中断、排他模式的锁获取过程就完成了，获取失败的节点在队列中阻塞，等待前驱节点的唤醒。</p>
<h3 id="释放过程"><a href="#释放过程" class="headerlink" title="释放过程"></a>释放过程</h3><p>继续看排他模式，源码如下：</p>
<pre><code>public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
</code></pre><p>代码逻辑：如果尝试释放锁成功，则调用unparkSuccessor方法唤醒头结点的后继节点。</p>
<pre><code>private void unparkSuccessor(Node node) {
    /*
     * If status is negative (i.e., possibly needing signal) try
     * to clear in anticipation of signalling.  It is OK if this
     * fails or if status is changed by waiting thread.
     */
    int ws = node.waitStatus;
    if (ws &lt; 0)
        compareAndSetWaitStatus(node, ws, 0);

    /*
     * Thread to unpark is held in successor, which is normally
     * just the next node.  But if cancelled or apparently null,
     * traverse backwards from tail to find the actual
     * non-cancelled successor.
     */
    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);
}
</code></pre><h3 id="排它锁实例ReentrantLock"><a href="#排它锁实例ReentrantLock" class="headerlink" title="排它锁实例ReentrantLock"></a>排它锁实例ReentrantLock</h3><p>ReentrantLock实现了Lock接口，提供公平与非公平两种模式，分别由静态内部类NonfairSync和FairSync支撑，这两个静态内部类都是抽象内部类Sync的子类，而Sync继承自AQS。</p>
<h4 id="公平模式"><a href="#公平模式" class="headerlink" title="公平模式"></a>公平模式</h4><p>可以看到公平模式的lock方法直接调用了AQS acquire()方法：</p>
<pre><code>final void lock() {
        acquire(1);
    }
</code></pre><p>公平模式的tryAcquire方法：</p>
<pre><code>protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
        //在CAS设置同步状态之前，加了一个hasQueuedPredecessors()，如果已经有前驱在排队了，那么获取失败，也就是说对于每个线程都是严格排队的，即所谓公平。
            if (!hasQueuedPredecessors() &amp;&amp;
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &lt; 0)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);
            return true;
        }
        return false;
    }
</code></pre><h4 id="非公平模式"><a href="#非公平模式" class="headerlink" title="非公平模式"></a>非公平模式</h4><p>直接上代码：</p>
<pre><code>final void lock() {
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            acquire(1);
    }
</code></pre><p>不管是否有前驱节点在排队，先直接以0为预期值CAS设置同步状态，如果成功了就设置当前线程为获取锁的线程。如果失败则调用AQS acquire获取锁逻辑（上面讲过，先尝试，不成功再排队）。并不考虑当前是否已经有前驱节点在排队，即所谓非公平。</p>
<p>我们再看一下NonfairSync所对应的tryAcquire方法：</p>
<pre><code>final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
       //如果当前线程和当前拥有锁的线程是同一个线程，允许重入，只需要将同步状态+1表示重入次数即可。
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &lt; 0) // overflow
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);
            return true;
        }
        return false;
    }
</code></pre><p>非公平模式相较于公平模式少了一些排队的开销，在实际应用中有更大的吞吐量。</p>
<p>公平模式和非公平模式的释放过程是一致的，都是直接调用AQS release(int arg)方法，我们来看其对应的tryRelease()方法：</p>
<pre><code>protected final boolean tryRelease(int releases) {
        //获得一次锁，同步状态+1，释放时每释放一次同步状态-1，直到状态为0，可重入锁全部释放完毕。
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }
</code></pre><p>如前文所述，AQS还支持共享模式获取锁。</p>
<h1 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h1><h3 id="释放过程-1"><a href="#释放过程-1" class="headerlink" title="释放过程"></a>释放过程</h3><p>因为共享锁的获取过程中调用了释放过程，我们这里先说明共享锁的释放过程。AQS中releaseShared()方法：</p>
<pre><code>public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}

private void doReleaseShared() {
    /*
     * Ensure that a release propagates, even if there are other
     * in-progress acquires/releases.  This proceeds in the usual
     * way of trying to unparkSuccessor of head if it needs
     * signal. But if it does not, status is set to PROPAGATE to
     * ensure that upon release, propagation continues.
     * Additionally, we must loop in case a new node is added
     * while we are doing this. Also, unlike other uses of
     * unparkSuccessor, we need to know if CAS to reset status
     * fails, if so rechecking.
     */
    for (;;) {
        Node h = head;
        if (h != null &amp;&amp; h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
            //暂时不清楚这里两个循环CAS的意义具体是啥
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                    //在释放共享锁的同时唤醒后继节点
                unparkSuccessor(h);
            }
            else if (ws == 0 &amp;&amp;
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        //这里也不是很清楚，如果一个共享节点的后续节点是排他节点，那么共享节点setHeadAndPropagate时，并不会唤醒后继节点。如果共享节点的后继是共享型的，那么该后继改变了head节点意味着它已经获取了锁，这里如果重新循环，那么不管该后继的后继是共享型的还是排他型的，该后继都会唤醒它的后继？
        if (h == head)                   // loop if head changed
            break;
    }
}
</code></pre><h3 id="获取过程-1"><a href="#获取过程-1" class="headerlink" title="获取过程"></a>获取过程</h3><p>AQS的acquireShared方法：</p>
<pre><code>public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}
</code></pre><p>先尝试获取共享锁，失败后进入doAcquireShared()方法，其中tryAcquireShared()方法由子类实现。</p>
<pre><code>private void doAcquireShared(int arg) {
//添加新共享类型的节点
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                //tryAcquireShared返回int整数，负数表示失败，0表示成功但是后面不能再继续有线程获取共享锁了，正数表示成功并且后面的线程可以继续获取共享锁。
                if (r &gt;= 0) {
                //如果获取成功，将当前节点设置为头节点并传播
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            //获取失败则排队阻塞
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // Record old head for check below
    setHead(node);
    /*
     * Try to signal next queued node if:
     *   Propagation was indicated by caller,
     *     or was recorded (as h.waitStatus) by a previous operation
     *     (note: this uses sign-check of waitStatus because
     *      PROPAGATE status may transition to SIGNAL.)
     * and
     *   The next node is waiting in shared mode,
     *     or we don&apos;t know, because it appears null
     *
     * The conservatism in both of these checks may cause
     * unnecessary wake-ups, but only when there are multiple
     * racing acquires/releases, so most need signals now or soon
     * anyway.
     */
     //注意到在获取共享锁的时候，设置当前节点为头结点，如果允许其他线程继续获取共享锁（tryAcquireShared返回大于0），且下一个等待线程是共享类型的节点，将进入doReleaseShared()方法
    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();
    }
}
</code></pre><p>共享锁在获取成功后，如果条件允许且下一个等待线程是共享类型的节点，那么该线程会唤醒它。与排他锁相比，共享锁不仅在释放锁时唤醒后继节点，在获取锁成功后亦会唤醒后继的共享节点。</p>
<h1 id="共享锁-排他锁示例ReentrantReadWriteLock"><a href="#共享锁-排他锁示例ReentrantReadWriteLock" class="headerlink" title="共享锁/排他锁示例ReentrantReadWriteLock"></a>共享锁/排他锁示例ReentrantReadWriteLock</h1><p>ReentrantReadWriteLock实现了ReadWriteLock接口，同时提供读锁和写锁。它共有5个内部类：ReadLock，WriteLock，Sync，FairSync，NonfairSync。<br>Sync继承自AQS，不像ReentrantLock中的Sync，只实现了AQS的排他锁的获取与释放。这里一并实现了AQS的排它锁获取与释放（tryAcquire/tryRelease）和共享锁的获取和释放（tryAcquireShared/tryReleaseShared），AQS的灵活性可见一斑。<br>FairSync与NonfairSync继承Sync提供了公平性与非公平性的选择。<br>ReadLock与WriteLock均实现了Lock接口，两者使用同一个已确定公平性策略的Sync对象作为同步器来管理读锁和写锁的并发控制。<br>ReentrantReadWriteLock相比于ReentrantLock，多了共享锁，在读多于写的场景下，前者比后者能提供更大的吞吐量。</p>
<p>ReentrantReadWriteLock实现基于：并发读共享资源不会有线程安全问题，而只要操作中含有并发写就会带来线程安全问题，必须正确同步。并发读由共享锁-读锁支持，并发写由排他锁-写锁支持。</p>
<p>来看一下ReentrantReadWriteLock中的Sync是如何做到的吧。</p>
<h2 id="同步状态的表示"><a href="#同步状态的表示" class="headerlink" title="同步状态的表示"></a>同步状态的表示</h2><p>由于AQS只有一个int型state变量表示同步状态，而读写锁需要同时表示读锁和写锁的状态，Sync中将该state变量一拆为二，高16位用于表示读锁状态，低16位用于表示写锁状态。</p>
<pre><code>static int sharedCount(int c)    { return c &gt;&gt;&gt; SHARED_SHIFT; }
static int exclusiveCount(int c) { return c &amp; EXCLUSIVE_MASK; }
</code></pre><p>两个方法通过位运算在同一个int变量上维护了读锁和写锁的状态。<br>对于读锁，sharedCount返回值反映了当前获取读锁的次数，对于读线程的重入计数，由ThreadLocal的子类ThreadLocalHoldCounter变量readHolds支撑，该变量为每个读线程记录了重入数目，原理可以阅读ThreadLocal源码。<br>对于写锁，exclusiveCount返回值反应了当前写锁的获取状态和重入次数。</p>
<h2 id="公平性策略"><a href="#公平性策略" class="headerlink" title="公平性策略"></a>公平性策略</h2><pre><code>abstract boolean readerShouldBlock();
abstract boolean writerShouldBlock();
</code></pre><p>Sync定义了两个抽象方法，用来控制并发线程入队的公平性。<br>非公平：</p>
<pre><code>static final class NonfairSync extends Sync {
    private static final long serialVersionUID = -8159625535654395037L;
    //非公平策略下，写线程总是可以直接竞争锁
    final boolean writerShouldBlock() {
        return false; // writers can always barge
    }
    //读线程在同步等待队列的第一个节点不为排他型节点时也可以直接竞争锁，但是如果第一个节点为排他型节点，该读线程将阻塞，这样可以防止在排队的写线程长期饥饿，不公平中为写线程争取了公平。
    final boolean readerShouldBlock() {
        /* As a heuristic to avoid indefinite writer starvation,
         * block if the thread that momentarily appears to be head
         * of queue, if one exists, is a waiting writer.  This is
         * only a probabilistic effect since a new reader will not
         * block if there is a waiting writer behind other enabled
         * readers that have not yet drained from the queue.
         */
        return apparentlyFirstQueuedIsExclusive();
    }
}
//检查同步等待队列中的第一个节点是否是排他型，如果是排他型则返回true。
final boolean apparentlyFirstQueuedIsExclusive() {
    Node h, s;
    return (h = head) != null &amp;&amp;
        (s = h.next)  != null &amp;&amp;
        !s.isShared()         &amp;&amp;
        s.thread != null;
}
</code></pre><p>公平：如果有前驱节点在排队，则阻塞。</p>
<pre><code>static final class FairSync extends Sync {
    private static final long serialVersionUID = -2274990926593161451L;
    final boolean writerShouldBlock() {
        return hasQueuedPredecessors();
    }
    final boolean readerShouldBlock() {
        return hasQueuedPredecessors();
    }
}
</code></pre><h2 id="写锁的获取和释放"><a href="#写锁的获取和释放" class="headerlink" title="写锁的获取和释放"></a>写锁的获取和释放</h2><h4 id="获取过程-2"><a href="#获取过程-2" class="headerlink" title="获取过程"></a>获取过程</h4><p>获取写锁时必须没有读锁。</p>
<pre><code>protected final boolean tryAcquire(int acquires) {
        /*
         * Walkthrough:
         * 1. If read count nonzero or write count nonzero
         *    and owner is a different thread, fail.
         * 2. If count would saturate, fail. (This can only
         *    happen if count is already nonzero.)
         * 3. Otherwise, this thread is eligible for lock if
         *    it is either a reentrant acquire or
         *    queue policy allows it. If so, update state
         *    and set owner.
         */
        Thread current = Thread.currentThread();
        int c = getState();
        int w = exclusiveCount(c);
        if (c != 0) {
            // (Note: if c != 0 and w == 0 then shared count != 0)
            //当state不为0，可能是有读锁或者是有写锁，如果写锁为0，当前线程不是拥有锁的线程，则获取失败。
            if (w == 0 || current != getExclusiveOwnerThread())
                return false;
            if (w + exclusiveCount(acquires) &gt; MAX_COUNT)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            // Reentrant acquire
            //如果写锁不为0，那么读锁肯定为0，当前线程拥有锁，直接重入，获取成功。
            setState(c + acquires);
            return true;
        }
        //由公平性策略检查是否需要阻塞
        if (writerShouldBlock() ||
            !compareAndSetState(c, c + acquires))
            return false;
        setExclusiveOwnerThread(current);
        return true;
    }
</code></pre><h4 id="释放过程-2"><a href="#释放过程-2" class="headerlink" title="释放过程"></a>释放过程</h4><p>先检查当前线程是否拥有锁，然后将state写锁计数部分减去释放数。</p>
<pre><code>protected final boolean tryRelease(int releases) {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        int nextc = getState() - releases;
        boolean free = exclusiveCount(nextc) == 0;
        if (free)
            setExclusiveOwnerThread(null);
        setState(nextc);
        return free;
    }
</code></pre><h2 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h2><h4 id="获取过程-3"><a href="#获取过程-3" class="headerlink" title="获取过程"></a>获取过程</h4><p>tryAcquireShared与fullTryAcquireShared代码有部分重复，tryAcquireShared就是先尝试获取，失败再进入fullTryAcquireShared，这里直接分析fullTryAcquireShared方法。读锁获取时必须没有写锁。</p>
<pre><code>final int fullTryAcquireShared(Thread current) {
        /*
         * This code is in part redundant with that in
         * tryAcquireShared but is simpler overall by not
         * complicating tryAcquireShared with interactions between
         * retries and lazily reading hold counts.
         */
        HoldCounter rh = null;
        for (;;) {
            int c = getState();
            if (exclusiveCount(c) != 0) {
                if (getExclusiveOwnerThread() != current)
                    return -1;
                // else we hold the exclusive lock; blocking here
                // would cause deadlock.
                //存在一个时刻，既没有读锁也没有写锁，但是此时可能一个读锁和一个同步队列中的写锁竞争
            } else if (readerShouldBlock()) {
                // Make sure we&apos;re not acquiring read lock reentrantly
                if (firstReader == current) {
                    // assert firstReaderHoldCount &gt; 0;
                } else {
                    if (rh == null) {
                        rh = cachedHoldCounter;
                        if (rh == null || rh.tid != current.getId()) {
                            rh = readHolds.get();
                            if (rh.count == 0)
                            //帮助GC
                                readHolds.remove();
                        }
                    }
                    if (rh.count == 0)
                        return -1;
                }
            }
            if (sharedCount(c) == MAX_COUNT)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
             //将整个过程放在一个自旋里，就是有可能前面的条件允许，但是多个读线程同时CAS修改state值时有可能失败，自旋保证条件允许的情况下一定能线程安全的修改成功。
            if (compareAndSetState(c, c + SHARED_UNIT)) {
            //为相应的读线程记录重入数目，并且为最后一个访问的线程设置缓存
                if (sharedCount(c) == 0) {
                    firstReader = current;
                    firstReaderHoldCount = 1;
                } else if (firstReader == current) {
                    firstReaderHoldCount++;
                } else {
                    if (rh == null)
                        rh = cachedHoldCounter;
                    if (rh == null || rh.tid != current.getId())
                        rh = readHolds.get();
                    else if (rh.count == 0)
                        readHolds.set(rh);
                    rh.count++;
                    cachedHoldCounter = rh; // cache for release
                }
                return 1;
            }
        }
    }
</code></pre><h4 id="释放过程-3"><a href="#释放过程-3" class="headerlink" title="释放过程"></a>释放过程</h4><p>代码逻辑：先将ThreadLocal变量中对应线程的重入计数值减1，并注意清除不再使用的ThreadLocal变量帮助GC，最后用循环CAS设置state读数目。</p>
<pre><code>protected final boolean tryReleaseShared(int unused) {
        Thread current = Thread.currentThread();
        if (firstReader == current) {
            // assert firstReaderHoldCount &gt; 0;
            if (firstReaderHoldCount == 1)
                firstReader = null;
            else
                firstReaderHoldCount--;
        } else {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != current.getId())
                rh = readHolds.get();
            int count = rh.count;
            if (count &lt;= 1) {
                readHolds.remove();
                if (count &lt;= 0)
                    throw unmatchedUnlockException();
            }
            --rh.count;
        }
        for (;;) {
            int c = getState();
            int nextc = c - SHARED_UNIT;
            if (compareAndSetState(c, nextc))
                // Releasing the read lock has no effect on readers,
                // but it may allow waiting writers to proceed if
                // both read and write locks are now free.
                return nextc == 0;
        }
    }
</code></pre><hr>
<h1 id="条件变量-1"><a href="#条件变量-1" class="headerlink" title="条件变量"></a>条件变量</h1><p>由于条件变量的条件常常与共享资源的状态有关，条件变量常常与互斥量一起使用，也就使得在条件变量上的wait()/notify()操作必须要先获取互斥量。ConditionObject作为AQS的内部类也合情合理。实际上，在Lock接口中的newCondition()方法也表明了ConditionObject对象对锁的依赖性。由此，对于ConditionObject类的方法就不需要再另外做同步了。</p>
<p>每个对象都有wait()/notify()方法，在synchronized关键字的实现中，每一个对象一个管程，获取了对象的管程之后，才能进行wait()/notify()操作，一个对象一个条件变量。在许多场景下，线程需要在多个条件变量上阻塞，这时候synchronized关键字就无能为力了。但是AQS的条件变量没有这样的限制，可以创建多个条件变量ConditionObject。</p>
<p>ConditionObject实现了Condition接口，内部维护了一个带有首尾引用的FIFO单链表。节点类型依然为Node。主要有三类方法：await、notify和监控方法，其中await也提供了不可中断、可中断、超时三类方法。</p>
<h2 id="await-notify机制主要逻辑："><a href="#await-notify机制主要逻辑：" class="headerlink" title="await/notify机制主要逻辑："></a>await/notify机制主要逻辑：</h2><p>假设有线程A和线程B，线程A先获取锁，执行….，然后在某个conditionObject上await，调用await意味着线程A释放了其获得的锁并进入等待队列阻塞自己（注意：此时await方法并没有返回）。</p>
<p>线程B此时可以获取锁，执行….，在A线程等待的conditionObject上调用signal方法，将A线程从等待队列中移至锁的同步队列中去竞争锁，然后B线程释放锁。</p>
<p>此时A线程在同步队列中再次竞争到锁，然后此时await方法才返回，A线程继续执行await方法之后的代码。await有一个隐式的释放锁-阻塞-获取锁的过程。</p>
<h2 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h2><p>当一个线程在条件对象上等待时，先检查条件队列中是否有已取消的线程，如果有则清除（这里由于条件队列是单链表，每次清除都需要从头到尾遍历一遍），然后以当前线程构建新的节点，节点类型为CONDITION，加入条件队列。</p>
<pre><code>private Node addConditionWaiter() {
        Node t = lastWaiter;
        // If lastWaiter is cancelled, clean out.
        if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {
            unlinkCancelledWaiters();
            t = lastWaiter;
        }
        Node node = new Node(Thread.currentThread(), Node.CONDITION);
        if (t == null)
            firstWaiter = node;
        else
            t.nextWaiter = node;
        lastWaiter = node;
        return node;
    }

public final void awaitUninterruptibly() {
        Node node = addConditionWaiter();
        //入队以后，当前线程需要释放锁，不论是读锁还是写锁，释放锁调用的是AQS的release方法，tryRelease后，就会唤醒同步队列中的后继节点竞争锁。
        int savedState = fullyRelease(node);
        boolean interrupted = false;
        //然后线程循环检测自己是否在同步队列上（后面将分析signal()方法主要是将Condition节点移至锁对象所维护的同步队列上），如果不在同步队列表示自己仍需在条件对象上等待，如果已经在同步队列，线程从循环中退出。
        while (!isOnSyncQueue(node)) {
            LockSupport.park(this);
            if (Thread.interrupted())
                interrupted = true;
        }
        //等待的线程节点由等待队列进入同步队列，通过acquireQueued参与到锁的竞争中去。前面讲过这个方法，如果有机会就尝试获取锁。如果自己前面还有线程在等待，则将前者的状态设置为SIGNAL，然后自己阻塞等待前驱节点的唤醒。
        //如果获取锁成功，再处理中断情况，await方法返回（条件已经满足了），继续执行后面的代码。也就是说await方法返回时，是一定再次获取了锁的。
        if (acquireQueued(node, savedState) || interrupted)
            selfInterrupt();
    }
</code></pre><h2 id="signal方法"><a href="#signal方法" class="headerlink" title="signal方法"></a>signal方法</h2><p>siganl方法只做一个事情：将条件变量等待队列的节点移至锁的同步队列，这样在条件变量上等待的线程就可以参与锁的竞争，当那些线程获取到锁后即从await方法中返回，继续执行。signalAll即将所有等待队列上的节点都转移至同步队列参与竞争。<br>signal方法主要调用了transferForSignal方法：</p>
<pre><code>final boolean transferForSignal(Node node) {
    /*
     * If cannot change waitStatus, the node has been cancelled.
     */
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;

    /*
     * Splice onto queue and try to set waitStatus of predecessor to
     * indicate that thread is (probably) waiting. If cancelled or
     * attempt to set waitStatus fails, wake up to resync (in which
     * case the waitStatus can be transiently and harmlessly wrong).
     */
     //将节点移至同步队列队尾
    Node p = enq(node);
    int ws = p.waitStatus;
    //如果前驱节点无法通知该节点，则唤醒该节点的线程，该线程自己要么去竞争锁，要么维护同步队列（清除取消节点）并设置其前驱节点的状态为SIGNAL
    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}
</code></pre><hr>
<h1 id="可中断和超时"><a href="#可中断和超时" class="headerlink" title="可中断和超时"></a>可中断和超时</h1><p>AQS中获取锁的中断和ConditionObject的中断机制稍有不同，我们分开讲。</p>
<h2 id="锁的获取"><a href="#锁的获取" class="headerlink" title="锁的获取"></a>锁的获取</h2><p>主要涉及的方法有acquire和acquireInterruptibly，acquireShared和acquireSharedInterruptibly。</p>
<p>再来看acquire和acquireInterruptibly的源码：</p>
<pre><code>public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
public final void acquireInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
}
</code></pre><p>主要区别在于tryAcquire失败后的处理，再看acquireQueued：</p>
<pre><code>final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                //在成功获取锁后将中断信息返回，最终在acquire中再次调用selfInterrupt方法设置线程中断标志位
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
            //在检查到被中断后只是将中断标志位设置为true
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre><p>而acquireInterruptibly呢：</p>
<pre><code>private void doAcquireInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
             //在检查到有中断发生后直接抛异常   
                throw new InterruptedException();
        }
    } finally {
    //抛异常会导致获取锁失败，进而该获取锁线程节点被取消
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre><p>acquireShared和acquireSharedInterruptibly的中断机制与上述一致，不再赘述。</p>
<h2 id="ConditionObject–await方法的中断机制"><a href="#ConditionObject–await方法的中断机制" class="headerlink" title="ConditionObject–await方法的中断机制"></a>ConditionObject–await方法的中断机制</h2><p>在Doug Lea的论文<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">The java.util.concurrent Synchronizer Framework</a>中有这么一段话：</p>
<blockquote>
<p>As revised in JSR133, these require that if an interrupt occurs before a signal,then the await method must, after re-acquiring the lock, throw InterruptedException.   But   if   it   is   interrupted   after a signal,   then   the   method   must   return   without   throwing  an exception, but with its thread interrupt status set.</p>
</blockquote>
<p>按照JSR133的要求，在signal之前被中断的线程在重新获取锁后要抛InterruptedException，而在signal之后被中断的线程从await返回时不能抛异常，而是设置线程的中断标志位。也就是说在线程处于等待阶段时，抛出异常；在竞争锁阶段，设置标志位。</p>
<p>源码中也定义了两个变量来表示这两种情况：</p>
<pre><code>/** Mode meaning to reinterrupt on exit from wait */
    private static final int REINTERRUPT =  1;
    /** Mode meaning to throw InterruptedException on exit from wait */
    private static final int THROW_IE    = -1;
</code></pre><p>  并在可中断的await方法后面都加入了方法：</p>
<pre><code>private void reportInterruptAfterWait(int interruptMode)
      throws InterruptedException {
      if (interruptMode == THROW_IE)
          throw new InterruptedException();
      else if (interruptMode == REINTERRUPT)
          selfInterrupt();
  }
</code></pre><p>根据情况的不同await方法退出时有不同的处理。</p>
<p>以await()方法为例，我们来看它是如何做到的：</p>
<pre><code>public final void await() throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        int interruptMode = 0;

        while (!isOnSyncQueue(node)) {
            LockSupport.park(this);
            //这里有一个check方法
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
        }
        if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null) // clean up if cancelled
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
    }
</code></pre><p>解决问题的关键在于Node节点的状态。当节点处于等待队列中时，Node的状态为Condition。当节点被移至同步队列中后（signal后），Node的状态为0。</p>
<p>当线程在等待队列中等待时，如果有中断发生，线程从park()方法返回（park()方法也可能无端返回，这里略去），进入checkInterruptWhileWaiting方法：</p>
<pre><code>private int checkInterruptWhileWaiting(Node node) {
        return Thread.interrupted() ?
            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
            0;
    }
</code></pre><p>   重点看其中的transferAfterCancelledWait方法：</p>
<pre><code>   final boolean transferAfterCancelledWait(Node node) {
   //如果此时CAS操作成功了，证明还没有signal信号将节点移至同步队列，也就是中断发生在等待阶段。那么本操作将节点移至同步队列，返回true。这里返回true，即指示await方法返回时要抛出异常
    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
        enq(node);
        return true;
    }
    /*
     * If we lost out to a signal(), then we can&apos;t proceed
     * until it finishes its enq().  Cancelling during an
     * incomplete transfer is both rare and transient, so just
     * spin.
     */
     //如果操作失败了，说明该节点要么已经在同步队列上了，要么就在去同步队列的路上，等待一下
    while (!isOnSyncQueue(node))
        Thread.yield();
    return false;//返回false则指示await()返回时设置中断标志位 不抛异常
}
</code></pre><p>再来分析await方法中进入同步队列后的情况：</p>
<pre><code>//如果在获取锁的过程中发生中断，属于设置标志位的情况。这里也可以看到调用的是acquire方法中的acquireQueued方法，不可中断，即中断发生了我只是做记录，并不对中断做什么处理，做下记录留给专门处理中断的代码去处理。
if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null) // clean up if cancelled
            unlinkCancelledWaiters();
        if (interruptMode != 0)
        //如果这两个阶段发生了中断的话，最后由该方法向调用线程报告中断情况，是抛出异常还是仅仅设置标志位
            reportInterruptAfterWait(interruptMode);
    }
</code></pre><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>超时部分比较简单，获取锁的过程中超时了直接返回获取失败，等待过程中超时了直接不再等待，移至同步队列中竞争锁。</p>
<h1 id="监控方法"><a href="#监控方法" class="headerlink" title="监控方法"></a>监控方法</h1><p>AQS中提供了不少监控同步队列和等待队列的状态的方法，这些方法在并发环境下获取的信息都是估计值，瞬时值。</p>
<blockquote>
<p>Java并发编程的艺术<br>JSR133<br>Doug Lea的论文<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">The java.util.concurrent Synchronizer Framework</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/02/Java并发机制（3）--synchronized关键字底层原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John What">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/11/02/Java并发机制（3）--synchronized关键字底层原理/" class="post-title-link" itemprop="url">Java并发机制（3）--synchronized关键字底层原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-11-02 10:32:52" itemprop="dateCreated datePublished" datetime="2017-11-02T10:32:52+08:00">2017-11-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 20:06:32" itemprop="dateModified" datetime="2019-01-24T20:06:32+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>synchronized关键字在Java语言层面提供了同步功能。</p>
<h1 id="synchronized同步的形式"><a href="#synchronized同步的形式" class="headerlink" title="synchronized同步的形式"></a>synchronized同步的形式</h1><p>Java中的任何对象都可以被锁。<br>有以下三种形式：</p>
<ul>
<li>对于普通同步方法，锁住的是当前实例对象</li>
<li>对于静态同步方法，锁住的是当前类的Class对象</li>
<li>对于同步方法块，锁住的是synchronized括号里配置的对象</li>
</ul>
<p>这三种形式在jvm里都是由管程来支撑的。<br>同步代码块在字节码层面插入了monitorenter和monitorexit指令，用于实现对管程的调用。<br>方法级的同步是隐式的，不需要在字节码中插入指令，它实现在方法调用和返回之中。JVM从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志位来确定一个方法是否为同步方法。如果调用指令检查到方法为同步方法，则JVM要求当前执行线程必须先成功持有管程。</p>
<h1 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h1><p>在hotspot虚拟机中，synchronized用的锁存在Java对象头里。非数组对象头分为两部分：</p>
<ol>
<li>Mark Word，存储对象自身的运行时数据，如hashcode,GC分代年龄，锁标志位等。</li>
<li>存储指向方法去对象类型数据的指针</li>
</ol>
<p>ps:数组对象额外一部分用于存储数组的长度。</p>
<p>在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。<br>|锁状态|存储内容|锁标志位|<br>|—-|||<br>|无锁|对象hashcode，GC分代年龄，偏向锁标志位：0|01|<br>|偏向锁|ThreadID，Epoch，对象分代年龄，偏向锁标志位：1|01|<br>|轻量级锁|指向栈中锁记录的指针/|00|<br>|重量级锁|指向互斥量（重量级锁）的指针/|10|<br>|GC标记|空/|11|</p>
<h1 id="JVM线程状态转化机制"><a href="#JVM线程状态转化机制" class="headerlink" title="JVM线程状态转化机制"></a>JVM线程状态转化机制</h1><p>线程阻塞/等待队列图：<br><img src="http://johnlw.cn/blog_thread_block_wait.jpg" alt="JVM协调结构图"></p>
<p>工作原理：当多个线程同时请求某个管程时，管程会设置几种状态来区分和组织协调请求的线程</p>
<ul>
<li>Contention List:所有请求锁的线程首先添加至竞争队列</li>
<li>Entry List:Contention List中有资格成为候选线程的添加至Entry List</li>
<li>Wait Set:调用wait()方法阻塞的线程添加至wait set</li>
<li>OnDeck:任何时候最多只能有一个线程正在竞争锁，即OnDeck</li>
<li>Owner:获得锁的线程</li>
<li>！Owner;释放锁的线程</li>
</ul>
<p>具体过程：<br>Contention List:<br>当有新线程竞争管程时，先添加至Contention List。Contention List是一个LIFO队列，新线程通过CAS操作将队列头节点设置为自己，再将next引用指向之前的头结点。Owner线程从队列尾取元素。<br>Entry List:<br>Entry List 和Contention List逻辑上同属等待队列，因为Contention List会被多个线程并发访问，就涉及到等待或者阻塞，为了尽可能利用CPU时间，建立Entry List。Owner线程在unlock时会从Contention List中迁移线程至Entry List，并指定EntryList的head节点为OnDeck。Owner并不是直接将锁传递给OnDeck，而是将竞争锁的权利交给OnDeck，OnDeck需要重新竞争锁，也就是由OnDeck主动获取。正如前面所说，Owner线程会与其他线程并发访问Contention List，存在等待或者阻塞的情况，如果让Owner线程直接交给OnDeck锁，就有可能出现Owner线程阻塞在Contention List上而不能及时将锁交付，浪费CPU时间。<br>Wait Set:<br>如果Owner线程被wait方法阻塞，则转移到WaitSet队列，当在某个时刻被notify/notifyAll唤醒，则再次转移到EntryList。</p>
<h1 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h1><p>在Contention List和Entry List中的线程均处于BLOCKED状态，Wait Set中的线程处于WAITING状态，所以直接进入等待队列会引起线程上下文切换。实际上，很多时候共享数据的锁定状态只会持续很短的时间，为了这段时间去阻塞和恢复线程并不值得。当发生竞争时，竞争线程在队列外自旋一段时间，在Owner线程释放锁之后，竞争线程可能立即得到锁，从而避免了线程阻塞带来的开销。</p>
<h1 id="锁升级机制"><a href="#锁升级机制" class="headerlink" title="锁升级机制"></a>锁升级机制</h1><p>Java 1.6引入了锁升级机制，提高了synchronized的同步性能。锁一共有四种状态：无锁、偏向锁、轻量级锁、重量级锁，这几个状态随着竞争情况的越来越激烈而逐步升级。锁只能升级而不能降级。</p>
<p>线程每次尝试竞争锁时，会首先在当前线程栈帧中建立一个锁记录（Lock Record），用于存储该对象Mark Word的拷贝（Displaced Mark Word）。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，由此背景引入了偏向锁。</p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>当一个对象Mark Word中的锁标志位为01（无锁/可偏向）时，</p>
<ol>
<li>当偏向锁标志位为0时，说明不是偏向锁，该对象管程未被任何线程获取，当前线程通过CAS操作尝试在对象Mark Word中记录当前线程ID，同时将偏向锁标志位置为1，当前线程即持有该对象的偏向锁。从此以后，持有偏向锁的线程进入该对象管程时，虚拟机将不再做任何同步操作。</li>
<li>当偏向锁标志位为1时，说明该对象已经有所偏向，如果偏向线程ID并不是当前线程，则尝试用CAS操作在Mark Word中记录自己的线程ID，如果成功，则该对象重偏向至当前线程。<h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3>如果重偏向失败，即已经出现竞争，偏向锁才会解锁。根据锁对象是否处于被锁定的状态，撤销偏向后对象要么重偏向，要么恢复到无锁状态，要么升级为轻量级锁–将锁标志位置为00。</li>
</ol>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><h3 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h3><p>当偏向锁膨胀为轻量级锁后，线程再次竞争锁时，将使用CAS尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功，则当前线程进入管程。如果失败，当前线程自旋获取锁。如果自旋获取锁失败，则竞争情况变得更加激烈了，锁膨胀为重量级锁，锁标志位置为10，同时当前线程进入阻塞态。</p>
<h3 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h3><p>轻量级锁解锁时，会使用CAS操作尝试将Displaced Mark Word替换回对象头上，如果成功，则表示在执行同步代码期间没有竞争发生或者竞争线程自旋没有结束。如果失败，说明其他线程在同步期间竞争失败了，在释放锁的同时，需要唤醒阻塞线程。</p>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>重量级锁的加锁和解锁由状态转化机制协调。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table>
<thead>
<tr>
<th>锁</th>
<th>背景</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得</td>
<td>加锁和解锁过程没有额外的开销</td>
<td>如果存在竞争，将带来额外的撤销开销</td>
<td>竞争不激烈的情况</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>在许多应用中，共享数据的锁定状态只会持续很短的一段时间</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果自旋竞争失败，会浪费CPU时间，还额外带来了CAS操作的开销（重量级锁没有CAS操作）</td>
<td>同步块执行速度非常快的情况</td>
</tr>
<tr>
<td>重量级锁</td>
<td>竞争激烈情况下必须程序正确同步</td>
<td>线程竞争不使用自旋，不会浪费CPU</td>
<td>线程阻塞，用户态内核态的切换，线程上下文切换等开销</td>
<td>竞争激烈，同步块执行时间长</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/31/Java并发机制（2）--volatile关键字/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John What">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/10/31/Java并发机制（2）--volatile关键字/" class="post-title-link" itemprop="url">Java并发机制（2）--volatile关键字</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-10-31 11:04:47" itemprop="dateCreated datePublished" datetime="2017-10-31T11:04:47+08:00">2017-10-31</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 17:25:51" itemprop="dateModified" datetime="2019-01-24T17:25:51+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关键字volatile提供了轻量级的同步机制，在理解volatile关键字之前先来看几个支撑技术。</p>
<h1 id="有序性的一种保证方式：内存屏障"><a href="#有序性的一种保证方式：内存屏障" class="headerlink" title="有序性的一种保证方式：内存屏障"></a>有序性的一种保证方式：内存屏障</h1><p>内存屏障是一组指令，分4类，这些指令指定了其前后指令的排序规则。</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad Barrier</td>
<td>Load1;LoadLoad;Load2</td>
<td>确保load1数据的装载先于load2及其后续所有load指令</td>
</tr>
<tr>
<td>StoreStore Barrier</td>
<td>Store1;StoreStore;Store2</td>
<td>确保Store1数据刷新到内存先于Store2及其后续所有store指令</td>
</tr>
<tr>
<td>LoadStore Barrier</td>
<td>Load1;LoadStore;Store2</td>
<td>确保load1数据的装载先于Store2及其后续所有store指令</td>
</tr>
<tr>
<td>StoreLoad Barrier</td>
<td>Store1;StoreLoad;Load2</td>
<td>确保Store1数据刷新到内存先于load2及其后续所有load指令 。<strong>注意</strong>：StoreLoad Barriers会使该屏障之前的所有内存访问指令（包括load和store指令）都执行完了之后，再执行屏障之后的内存访问指令。</td>
</tr>
</tbody>
</table>
<p>也就是说，在一个指令序列中插入了内存屏障，这些内存屏障会限制其前后指令的排序，而在两个内存屏障之间代码序列的重排序则没有约束。就好像屏障一样，被限制的指令无法越过。<br>同时也可以看出内存屏障将缓存值刷新到内存也起到了提供可见性的作用。</p>
<h1 id="强大的汇编指令前缀：Lock"><a href="#强大的汇编指令前缀：Lock" class="headerlink" title="强大的汇编指令前缀：Lock"></a>强大的汇编指令前缀：Lock</h1><p>lock前缀有三方面的功能：</p>
<ol>
<li>确保对内存的读-改-写操作原子执行。</li>
<li>禁止该指令，与之前和之后的读写指令重排序。</li>
<li>将写缓冲区的所有数据刷新到内存中，并且这个写操作会使其他CPU里缓存了该内存地址的数据无效。</li>
</ol>
<p>其中第2条和第3条共同起到了内存屏障的效果，并且是一并禁止了load和store指令。<br>可以看出，单单一个lock前缀就提供了原子性、有序性和可见性的三方面的可靠保证。</p>
<h1 id="volatile修饰变量"><a href="#volatile修饰变量" class="headerlink" title="volatile修饰变量"></a>volatile修饰变量</h1><p>被volatile修饰的变量有三个特性：</p>
<ol>
<li>原子性。对任意单个volatile变量的读、写具有原子性，但类似于volatile++这种<strong>复合操作</strong>没有原子性。</li>
<li>可见性。对一个volatile的读，总是能看到任意线程对这个变量的最后一次写入。</li>
<li>有序性。volatile禁止指令重排序。</li>
</ol>
<p>之所以volatile具有这三个特性，在于对volatile变量的操作有lock prefix支持。lock prefix提供了三方面的特性保证。</p>
<h1 id="锁与volatile"><a href="#锁与volatile" class="headerlink" title="锁与volatile"></a>锁与volatile</h1><p>锁的释放与volatile写具有同样的内存语义：释放锁和对volatile变量的写，JMM都会把线程对应的本地内存中的共享变量刷新到主内存中。<br>锁的获取与volatile读具有同样的内存语义：获取锁和对volatile变量的读，JMM都会将线程对应的本地内存置为无效，而是从主内存中重新读取。</p>
<h1 id="CAS与volatile"><a href="#CAS与volatile" class="headerlink" title="CAS与volatile"></a>CAS与volatile</h1><p>CAS操作具有volatile读和写的内存语义。该操作在执行cmpxchg指令之前，如果是多处理器，将会插入lock前缀。lock前缀提供了与volatile一致的内存语义。</p>
<h1 id="volatile重排序例子"><a href="#volatile重排序例子" class="headerlink" title="volatile重排序例子"></a>volatile重排序例子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"> </span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
<p>有可能语句2会在语句1之前执行，那么就可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<blockquote>
<p>现代操作系统<br>Java并发编程的艺术<br>深入理解Java虚拟机<br>Java并发编程实战<br>JSR-133<br>并发编程网<br>Intel IA-32</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/25/Java并发机制（1）--理论基础/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John What">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/10/25/Java并发机制（1）--理论基础/" class="post-title-link" itemprop="url">Java并发机制（1）--理论基础</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-10-25 14:16:14" itemprop="dateCreated datePublished" datetime="2017-10-25T14:16:14+08:00">2017-10-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 17:24:16" itemprop="dateModified" datetime="2019-01-24T17:24:16+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进程与线程概念"><a href="#进程与线程概念" class="headerlink" title="进程与线程概念"></a>进程与线程概念</h1><p>在现代操作系统中，进程支持多线程。</p>
<ul>
<li>进程是<strong>资源管理</strong>的最小单元，</li>
<li>线程是<strong>程序执行</strong>的最小单元。</li>
</ul>
<p>线程作为调度和分配的基本单位，进程作为资源分配的基本单位。</p>
<p>一个进程的组成实体可以分为两大部分：线程集和资源集。进程中的线程是动态的对象；代表了进程指令的执行。资源，包括地址空间、打开的文件、用户信息等等，由进程内的线程共享。</p>
<h1 id="多道程序设计模型"><a href="#多道程序设计模型" class="headerlink" title="多道程序设计模型"></a>多道程序设计模型</h1><p>计算机采用多道程序设计模型可以显著提高CPU的利用率。</p>
<h1 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h1><p>多进程：并行实体之间<strong>不共享</strong>同一个地址空间和所有可用数据。<br>多线程：并行实体之间<strong>共享</strong>同一个地址空间和所有可用数据。<br>1、线程比进程更加轻量级，线程的创建、切换等过程比进程开销小，线程的通信比进程间的通信简单。<br>2、进程的安全性高于线程，因为不共享。</p>
<h1 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h1><ul>
<li>内核线程实现</li>
<li>用户线程实现</li>
<li>用户线程加轻量级进程混合实现</li>
</ul>
<p><strong>Java线程实现</strong>在linux和windows平台上均采用的是内核线程实现，Java线程与内核线程为一比一的对应关系，也就是说Java线程由内核直接调度。</p>
<h1 id="多线程面临的挑战"><a href="#多线程面临的挑战" class="headerlink" title="多线程面临的挑战"></a>多线程面临的挑战</h1><ul>
<li>线程通信</li>
<li>上下文切换</li>
<li>死锁</li>
<li>资源限制</li>
<li>线程安全<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2>多线程相当于是多个线程为了完成<strong>一件</strong>“大事”而<strong>协同</strong>工作，那这多个线程之间如何协同就是线程通信的问题了。<br>线程间的通信是多线程编程的基础，线程间通信方式有两种：共享内存和消息传递。Java线程间的通信机制为共享内存方式。<br>线程间通信就要保证通信的可靠性，确保信息的可靠传递。这就涉及到线程安全的问题。<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2>线程安全最核心的概念是<strong>正确性</strong>。</li>
</ul>
<p><strong>在操作系统中</strong>，正确性是指多个线/进程读写共享数据，最后的结果与线/进程运行的精准时序无关，亦即<strong>不存在竞争条件</strong>。<br><strong>在Java中</strong>，正确性是指：某个类的行为与其规范完全一致。当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p>
<p>可以将Java线程安全按由强到弱分为5类，同时也可以看到线程安全的责任由对象本身向调用者的转移：</p>
<ol>
<li>不可变<br>不可变对象一定是线程安全的，无论是对象的方法还是方法的调用者，都不需要再采取任何的线程安全保障措施。（final关键字的使用）</li>
<li>绝对线程安全<br>不管运行时环境如何，调用者都不需要任何额外的同步措施。这个要求非常严格，Java API中大多数都不是绝对线程安全的类。</li>
<li>相对线程安全<br>保证对某个对象的单独操作是线程安全的，在调用的时候不需要做额外的同步措施。但是对于同一个对象的特定顺序的连续调用，可能需要在调用端做额外的同步手段（多为扩大同步范围）来保证调用的正确性。Java中大部分线程安全类属于相对线程安全。</li>
<li>线程兼容<br>对象本身不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境下的线程安全性。Java中的普通类。</li>
<li>线程对立<br>无论调用端是否采取了同步措施，都无法在并发环境中使用。</li>
</ol>
<h1 id="多线程编程的出发点"><a href="#多线程编程的出发点" class="headerlink" title="多线程编程的出发点"></a>多线程编程的出发点</h1><p>并发编程的基本出发点：<strong>先保证正确性，再提高效率</strong>。</p>
<p>保证正确性有三种方式：</p>
<ul>
<li>互斥同步</li>
<li>非阻塞同步</li>
<li>无同步方案</li>
</ul>
<p>互斥同步由互斥量（操作系统级或者Java语言级）支持，非阻塞同步由CAS指令支持，无同步方案为可重入代码和Java中的ThreadLocal变量。</p>
<p>提高效率中很重要的方式有重排序和减少上下文切换等。</p>
<hr>
<h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p>先来看一个最基础的支撑技术。</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子（atom）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。如有些场景下需要将读取变量值，再修改其值，再写入内存合并为一个原子操作完成。</p>
<p>intel处理器使用基于对缓存加锁和总线加锁的方式来实现多处理器之间的原子操作。<br>总线加锁：使用处理器提供的lock# 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞，该处理器可以独占共享内存。<br>缓存加锁：内存区域如果被缓存在处理器的缓存行中，并且在lock操作期间被锁定，那么当处理器执行锁操作回写到内存时，处理器修改内部的内存地址，通过缓存一致性协议来保证操作的原子性和可见性。缓存一致性协议会阻止同时修改由两个一上处理器缓存的内存数据，当处理器回写被锁定的缓存行的数据时，会使其他处理器的缓存行失效，其他处理器在下次读取时将重新从共享内存中读取。<br>可以看出原子操作的同时也提供了可见性。</p>
<p>再看操作系统如何保证正确性。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>对共享内存进行访问的程序片段成为临界区。<br>如果可以协调多线/进程不可能同时处于临界区，就能避免竞争条件（即互斥），从而保证正确性。同时在协调机制中也尽可能要求高效，一个好的协调方案，要满足以下4个条件：</p>
<ul>
<li>任何两个进/线程不能同时处于临界区</li>
<li>不应对CPU的速度和数量做任何假设（单核、多核、超线程） </li>
<li>临界区外运行的进/线程不得阻塞其他进/线程</li>
<li>不得使进/线程无限期等待进入临界区</li>
</ul>
<p>其中前两个条件是对正确性的保证，后两个条件是对效率的保证。</p>
<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>在原子操作的支撑下，有多种方案可以实现互斥。大体分为两类：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原理</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>忙等待</td>
<td>定义共享变量，设定某个值表示是否有线程进入临界区。如果已有线程进入，则各线程对该变量进行轮询，自旋等待，直到进入临界区</td>
<td>CPU自旋等待，如果短期内能进入临界区，避免了线程阻塞和上下文切换带来的开销</td>
<td>CPU空转，同时存在优先级反转问题</td>
<td>在有理由认为等待时间是非常短的情况下使用</td>
</tr>
<tr>
<td>等待/通知机制</td>
<td>一样定义共享变量，但是如果已有线程进入，则后面的线程将阻塞，当之前的线程出临界区时通知等待的线程进入临界区执行。</td>
<td>不会出现CPU空转，CPU占用极高的情况</td>
<td>线程阻塞将带来线程切换上下文的开销</td>
<td>临界区竞争激烈，且执行时间较长的情况下使用</td>
</tr>
</tbody>
</table>
<p>表格中的共享变量既可以使用信号量也可以使用互斥量，一般使用互斥量。</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>当仅有互斥量时且有线程在临界区时，其他线程将在互斥量上等待，然而很多情况下线程的执行不仅需要进入临界区，而且还需要满足一些其他的条件，当条件不满足时进入临界区线程不能继续执行也没有什么意义。这时候就需要条件变量了。</p>
<p>这时，一个线程运行需要条件变量满足，并且能锁住互斥量。如果锁住了互斥量，然而需要在某个条件变量上等待，线程将释放互斥量（给别的线程机会），进入阻塞态，等待其他线程在条件变量上唤醒自己，转入就绪态继续竞争互斥量。</p>
<h3 id="管程（Monitor）"><a href="#管程（Monitor）" class="headerlink" title="管程（Monitor）"></a>管程（Monitor）</h3><p>通过互斥量、条件变量以及相关的原子操作即可保证多线程通信的正确性，不过在多线程中，存在发送给变量的信号可能会丢失的情况，还有可能会出现死锁的情况，如果直接面向这些量编写多线程程序，会不可避免的出现各种奇奇怪怪的问题。为了简化多线程程序的编写，管程出现了。</p>
<p>管程实际上可以理解为是对互斥量、条件变量、以及组织协调多线程进入临界区算法的一个封装。高层代码只需要临界区交给管程管理就好了，管程会保证正确性。</p>
<p>JVM中管程与经典管程有本质区别：Java没有内嵌的条件变量。Java将等待/通知机制提出来作为wait()/notify()供程序员自定义使用，自定义条件变量（如某个对象）。</p>
<h2 id="非阻塞方案"><a href="#非阻塞方案" class="headerlink" title="非阻塞方案"></a>非阻塞方案</h2><p>互斥同步最主要的问题就是进行线程阻塞和唤醒带来的性能问题。是一种悲观的同步方案：不管有没有竞争，都要加解锁。<br>非阻塞方案是一种基于冲突检测的乐观方案：先进行操作，如果没有竞争，则操作就成功了；如果有竞争，产生了冲突，则采取补偿措施（一般即为不断尝试直到成功），这种方案并不需要阻塞线程。</p>
<p>CMPXCHG指令，该指令是原子操作。简单理解，cmpxchg指令接受两个参数，一个是将要修改的变量的预期值，一个是修改值，指令比较预期值与变量的实际值是否一致，如果一致则将修改值赋值给变量。否则不做修改。<br>由于这个指令是主动比较，一般会放到自旋中，适用于冲突比较少的场景。</p>
<h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>如果方法中不涉及共享数据，那么该方法不需要做任何同步。</p>
<ol>
<li>可重入代码<br> 可重入代码的特征如不依赖公共数据，不调用非可重入代码等，可重入代码中多为局部变量，不与其他代码共享，也就不存在数据竞争了。</li>
<li>线程本地存储–ThreadLocal</li>
</ol>
<hr>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>再看提高执行效率的方式：指令重排序。<br>重排序分三种：1.编译器优化的重排序。2.指令级并行的重排序。3.内存系统的重排序</p>
<h3 id="单线程重排序"><a href="#单线程重排序" class="headerlink" title="单线程重排序"></a>单线程重排序</h3><h4 id="数据依赖"><a href="#数据依赖" class="headerlink" title="数据依赖"></a>数据依赖</h4><p>如果两个操作访问同一个变量，且两个操作中有一个为写操作（读写/写读/写写），此时这两个操作之间存在数据依赖性。如果对存在数据依赖性的操作重排序，程序执行结果将会改变。因此，编译器和处理器不会改变存在数据依赖性的操作的执行顺序。</p>
<h4 id="as-if-serial模型"><a href="#as-if-serial模型" class="headerlink" title="as-if-serial模型"></a>as-if-serial模型</h4><p>as-if-serial：不管怎么重排序，单线程执行的结果不能被改变。<br>1、对存在数据依赖性的操作重排序非法。<br>2、对不存在数据依赖性的操作是否重排序不做要求。<br>as-if-serial为单线程提供了顺序执行的保证。</p>
<h3 id="多线程重排序"><a href="#多线程重排序" class="headerlink" title="多线程重排序"></a>多线程重排序</h3><h4 id="冲突访问"><a href="#冲突访问" class="headerlink" title="冲突访问"></a>冲突访问</h4><p>多线程中，对同一个共享字段或者数组元素存在两个访问（读或写），且至少有一个访问为写操作，称之为有冲突。</p>
<h4 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h4><ul>
<li>冲突访问</li>
<li>读写操作没有通过同步来排序</li>
</ul>
<p>当上述情况发生时，就存在数据竞争。代码中出现数据竞争时，常有可能会出现有违直觉的结果。<br>那么如何判断程序有没有正确的同步呢？<br>一个程序是<strong>正确同步</strong>的：<strong>当且仅当所有顺序一致的执行过程中都不存在数据竞争。</strong>不论调度系统如何调度，所有可能的执行顺序序列下，都不存在数据竞争。</p>
<p>那么应该如何来组织多线程程序的同步排序呢？</p>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>给定一个程序和该程序的一串执行轨迹，内存模型描述了该执行轨迹是否是该程序的一次合法执行。内存模型检查执行轨迹中的每次读操作，然后根据特定规则，检验该读操作观察到的写是否合法。<br>内存模型的一个高级、非正式的概述显示其是一组规则，规定了一个线程的写操作何时会对另一个线程可见。</p>
<h2 id="顺序一致性模型"><a href="#顺序一致性模型" class="headerlink" title="顺序一致性模型"></a>顺序一致性模型</h2><p>顺序一致性是程序执行过程中    可见性和顺序的强有力保证。</p>
<ul>
<li>有序性</li>
<li>原子性</li>
<li>可见性</li>
</ul>
<p>有序性：在顺序一致的执行过程中，所有动作（如读和写）间存在一个全序关系，与程序的顺序一致。<br>原子性和可见性：每个动作都是原子的并且立即对所有线程可见。</p>
<p>顺序一致性模型是一个理论参考模型，它在提供了极强的操作有序性、原子性和可见性的同时，使编译器和处理器优化（比如重排序）不再合法。</p>
<h2 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h2><p>JSR-133中对happens-before的定义：</p>
<ol>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。<strong>（有序性和可见性）</strong></li>
<li><p>两个操作之间存在happens-before关系，并不意味着java平台的具体实现必须要按照happens-before关系指定的顺序来执行。只要结果与按照happens-before关系来执行的一致，编译器和处理器的重排序是合法的。（最大限度的减少对编译器和处理器优化的约束）</p>
</li>
<li><p>程序顺序规则<br> 在一个线程内，按照程序代码顺序，书写在前面的操作happens-before书写在后面的操作。</p>
</li>
<li>管程锁规则<br> 一个unlock操作happens-before后面对同一个锁的lock操作。</li>
<li>volatile变量规则<br> 对一个volatile变量的写操作happens-before后面对这个变量的读操作。</li>
<li>线程启动规则<br> Thread对象的start()方法happens-before此线程的每一个动作。</li>
<li>线程终止规则<br> 线程中所有操作都happens-before对此线程的终止检测。</li>
<li>线程中断规则<br> 对线程interrupt()方法的调用happens-before被中断线程的代码检测到中断事件的发生。</li>
<li>对象终结规则<br> 一个对象的初始化完成（构造函数执行完毕）happens-before它的finalize()方法。</li>
<li>传递性<br> A happens-before B,B happens-before C,s.t. A happens-before C.</li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li>happens-before首先强调了前一个操作对后一个操作的顺序和可见性，但是同时又没有限定具体实现，只要求执行结果要与happens-before一致。那么在实际的代码执行中，happens-before和代码时间上的先行发生并没有直接关系。</li>
<li>happens-before允许违反因果关系的事情发生。（比如：out of thin air）</li>
</ul>
<h2 id="happens-before和as-if-serial"><a href="#happens-before和as-if-serial" class="headerlink" title="happens-before和as-if-serial"></a>happens-before和as-if-serial</h2><ul>
<li>as-if-serial保证单线程内程序的执行结果不被改变。向上向程序员保证程序执行顺序，向下约束编译器和处理器重排序的规则。</li>
<li>happens-before关系保证正确同步的多线程程序的执行结果不被改变。向上向程序员保证正确同步的多线程程序的执行结果正确性，向下约束编译器和处理器重排序的规则。</li>
</ul>
<hr>
<p>顺序一致性模型不允许重排序-过于严格，happens-before允许违反因果关系的事情发生-过于宽松，都不适合作为Java内存模型。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><ol>
<li>Java线程间的通信机制，JMM决定一个线程对共享变量的写入何时对另外一个线程可见。</li>
<li>屏蔽各种硬件和操作系统的内存访问差异，实现java跨平台的一致的内存访问效果</li>
<li>向上向程序员保证正确同步的程序具有顺序一致性</li>
<li>向下向编译器和处理器提供尽可能宽松的重排序约束规则</li>
<li>在happens-before的基础上提供了对因果关系的充分保证</li>
</ol>
<p>从<strong>抽象</strong>的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程读写共享变量的副本。本地内存是JMM的一个抽象概念，实际并不存在，它涵盖了缓存、寄存器以及其他的硬件和编译器优化。<br>同时定义了工作内存与主内存的交互操作协议：lock、unlock、read、load、use、assign、store、write共8种原子性操作以及它们之间的操作规则。</p>
<h2 id="Java内存模型的特征"><a href="#Java内存模型的特征" class="headerlink" title="Java内存模型的特征"></a>Java内存模型的特征</h2><p>Java内存模型建立在解决三个并发问题的基础上。</p>
<ul>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ul>
<p>对于原子性的保证：有read、load、use、assign、store、write这类数据访问的基本原子性操作，更大范围的可以用lock和unlock操作来保证。<br>对于可见性的保证：Java内存模型通过主内存作为可见性实现的媒介。写操作刷新回主内存，读操作重新读主内存实现前一个操作对后一个操作的可见性。<br>对于有序性的保证：happens-before规则保证基本操作的有序性，通过同步来保证其他操作的有序性。</p>
<p>下一篇讲解Java内存模型的具体实现，看Java如何在允许指令重排序的情况下保证正确同步。</p>
<blockquote>
<p>现代操作系统<br>Java并发编程的艺术<br>深入理解Java虚拟机<br>Java并发编程实战<br>JSR-133<br>并发编程网</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/11/数据结构与算法基础概念总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John What">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/05/11/数据结构与算法基础概念总结/" class="post-title-link" itemprop="url">数据结构与算法基础概念总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-05-11 21:08:28" itemprop="dateCreated datePublished" datetime="2017-05-11T21:08:28+08:00">2017-05-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 16:34:00" itemprop="dateModified" datetime="2019-01-24T16:34:00+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线性结构—–线性表"><a href="#线性结构—–线性表" class="headerlink" title="线性结构—–线性表"></a>线性结构—–线性表</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>具有相同数据类型数据元素的有限序列</p>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>逻辑上相邻的元素物理位置上也相邻，即数组</p>
<h3 id="链式表"><a href="#链式表" class="headerlink" title="链式表"></a>链式表</h3><p>逻辑上相邻的元素物理位置上不一定相邻，节点包含数据域和指针域，指针域指向后继节点。有单向链表，双向链表，循环链表。</p>
<h3 id="顺序与链式比较"><a href="#顺序与链式比较" class="headerlink" title="顺序与链式比较"></a>顺序与链式比较</h3><table>
<thead>
<tr>
<th>名称</th>
<th>存取方式</th>
<th>逻辑/物理结构</th>
<th>增删</th>
<th>查</th>
<th>空间分配</th>
<th>场景选择</th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序表</td>
<td>顺序/随机存取</td>
<td>逻辑物理均相邻</td>
<td>平均需要移动半个表的数据，O（N）</td>
<td>按值查找：无序O（N），有序二分查找O（logN）;按索引查找：O（1）</td>
<td>固定空间分配</td>
<td>固定空间，随机访问场景</td>
</tr>
<tr>
<td>链式表</td>
<td>顺序存取</td>
<td>逻辑物理不一定相邻</td>
<td>修改指针域即可，O（1），不过在链表中间插入或者删除需要先查找到相应元素，算上这部分时间就是O（N）</td>
<td>顺序访问O（N）</td>
<td>按需分配</td>
<td>不确定空间分配，插入/删除操作较多的场景（虽然有查找的时间，但是比较操作相对顺序表的移动操作更廉价）</td>
</tr>
</tbody>
</table>
<h1 id="操作受限的线性表"><a href="#操作受限的线性表" class="headerlink" title="操作受限的线性表"></a>操作受限的线性表</h1><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>只允许在一端进行插入和删除操作的线性表，FILO，顺序栈，链式栈</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>只允许在一端插入，而在另一端删除的线性表，FIFO</p>
<ul>
<li>顺序存储：顺序队列、循环队列</li>
<li>链式存储：单链表队列、双端队列（双入双出，双入单出，单入双出）</li>
</ul>
<h1 id="非线性结构—–树"><a href="#非线性结构—–树" class="headerlink" title="非线性结构—–树"></a>非线性结构—–树</h1><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><ul>
<li>图定义：树是无简单回路的有向连通图。</li>
<li>递归定义：树由根节点r和子树组成，每个子树的根节点都被来自r的边所连接<h3 id="路径、路径长、深度、高度、度"><a href="#路径、路径长、深度、高度、度" class="headerlink" title="路径、路径长、深度、高度、度"></a>路径、路径长、深度、高度、度</h3>从节点n1到nk的路径定义为n1,n2…nk这个节点序列，路径长为节点序列中边的条数。</li>
</ul>
<p><strong>深度和高度是基于路径的概念来定义的</strong>：节点n的深度为从根节点到n的唯一路径的长。节点n的高度定义为从节点n到一个叶子节点的最长路径的长。</p>
<p>节点的度：某节点孩子节点的个数</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>二叉树是每个节点都拥有不超过两个儿子的树。</p>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><ul>
<li>先序遍历：先根后左右儿子</li>
<li>中序遍历：先左儿子，再根，再右儿子</li>
<li>后序遍历：先左右儿子，再根</li>
<li>层序遍历：先根，再根的左右儿子根节点…需要借助队列</li>
</ul>
<h5 id="复原"><a href="#复原" class="headerlink" title="复原"></a>复原</h5><p>由先序序列和中序序列，后序序列和中序序列可以唯一的确定一棵二叉树，之所以都需要中序序列，是因为先序和后序只能确定根节点，而中序序列根据根节点的位置可以确定左右子树。</p>
<h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h5><p>树高度为h，含有2^h - 1个节点的二叉树，树中每一层都含有最多的节点。</p>
<h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><p>从插入元素的角度来说，完全二叉树就是按层序从上到下，从左往后插满每个节点，最后一层可以不插满</p>
<h5 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h5><p>一棵二叉树，其左子二叉树上的所有节点值都小于根节点，右子二叉树上的所有节点值都大于根节点。</p>
<h5 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h5><p>二叉树上任一节点的左子树和右子树的深度之差不超过1</p>
<h5 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h5><p>多路平衡查找树，m阶B树需要满足以下特性：</p>
<ul>
<li>根节点：至少有两棵子树</li>
<li>中间节点（非根非叶节点）：子树数目要求大于等于（m/2）（向上取整），小于等于m</li>
<li>叶结点：所有叶结点都在同一层次上</li>
</ul>
<h5 id="表达式树相关"><a href="#表达式树相关" class="headerlink" title="表达式树相关"></a>表达式树相关</h5><p>叶子节点存操作数，非叶子节点存操作符。<br>表达式树的中序遍历得中缀表达式，后序遍历得后缀表达式。</p>
<p>中缀表达式转后缀表达式：借助栈。读取中缀表达式，遇到操作数直接输出，遇到操作符即准备入栈，入栈前先比较栈顶操作符与当前操作符的优先级，如果栈顶优先级高或者平级，输出直至低优先级，然后再入栈。对于括号：左括号具有最高优先级，括号内的操作符出入栈跟之前一样，遇到右括号将操作符依次出栈直到左括号。注：括号不输出。</p>
<p>后缀表达式求值：借助栈。读取后缀表达式，操作数直接入栈，遇到操作符弹出两个操作数进行计算，结果入栈，继续读取…以此类推，直至结束</p>
<p>后缀表达式构建表达式树：借助栈。操作数作为单节点入栈，遇到操作符，以操作符作为根节点，弹出两个操作数作为右、左儿子，最后将操作符节点入栈…以此类推，直至结束</p>
<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><p>键值对的集合，通过散列函数计算键对应的值的存放位置，之后可以通过键直接访问值。</p>
<h5 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h5><p>将关键字映射到相应位置的函数。如果两个不同的key值，经散列后位置相同，这种情况称为冲突或者碰撞。</p>
<p>每次对散列表的操作，都需要经过散列函数，散列函数的选择应该简单以节省时间、散列均匀以避免碰撞。</p>
<h5 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h5><p>散列表中元素的个数与该表大小的比值。</p>
<h5 id="碰撞处理"><a href="#碰撞处理" class="headerlink" title="碰撞处理"></a>碰撞处理</h5><h6 id="分离连接法"><a href="#分离连接法" class="headerlink" title="分离连接法"></a>分离连接法</h6><p>将同一个散列值的不同元素保存在同一个链表里，并将后进入的元素放在链表的前端。</p>
<h6 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h6><p>出现碰撞以后，用新的函数继续找位置，直到找到空的位置为止</p>
<ul>
<li>线性探测：线性函数查找，会出现一次聚集</li>
<li>平方探测：二次函数查找，会出现二次聚集<h6 id="再散列（扩容）"><a href="#再散列（扩容）" class="headerlink" title="再散列（扩容）"></a>再散列（扩容）</h6>当散列表中元素的数量达到装填因子时，新建一个大的散列表，将原散列表中的元素重新计算散列值并放入新的散列表中<h1 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h1></li>
</ul>
<blockquote>
<p><a href="https://www.zhihu.com/question/20761771/answer/19996299" target="_blank" rel="noopener">https://www.zhihu.com/question/20761771/answer/19996299</a><br><a href="http://stackoverflow.com/questions/33923/what-is-tail-recursion" target="_blank" rel="noopener">http://stackoverflow.com/questions/33923/what-is-tail-recursion</a><br><a href="http://www.cnblogs.com/Anker/archive/2013/03/04/2943498.html" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/archive/2013/03/04/2943498.html</a></p>
</blockquote>
<h1 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h1><p><a href="http://blog.csdn.net/fanzheng220112583/article/details/7719228" target="_blank" rel="noopener">http://blog.csdn.net/fanzheng220112583/article/details/7719228</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/09/后缀表达式的计算器Java实现/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="John What">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/05/09/后缀表达式的计算器Java实现/" class="post-title-link" itemprop="url">后缀表达式的计算器Java实现</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-05-09 13:42:58" itemprop="dateCreated datePublished" datetime="2017-05-09T13:42:58+08:00">2017-05-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 15:35:18" itemprop="dateModified" datetime="2019-01-24T15:35:18+08:00">2019-01-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>直接上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package cn.john.cal;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @ClassName: Operators</span><br><span class="line"> * </span><br><span class="line"> * @Description: 操作符枚举</span><br><span class="line"> * </span><br><span class="line"> * @author: John</span><br><span class="line"> * </span><br><span class="line"> * @date: 2017年5月9日 下午22:05:16</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public enum OperatorsEnum &#123;</span><br><span class="line"></span><br><span class="line">	PLUS(0, &apos;+&apos;), MINUS(0, &apos;-&apos;), MULTIPLY(1, &apos;*&apos;), DIVIDE(1, &apos;/&apos;), MODULAR(1, &apos;%&apos;), LEFT_BRACKET(2,</span><br><span class="line">			&apos;(&apos;), RIGHT_BRACKET(2, &apos;)&apos;);</span><br><span class="line"></span><br><span class="line">	public Integer prior;// 优先级</span><br><span class="line">	public Character operator;// 操作符</span><br><span class="line"></span><br><span class="line">	private OperatorsEnum(int prior, char operator) &#123;</span><br><span class="line">		this.prior = prior;</span><br><span class="line">		this.operator = operator;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return String.valueOf(operator);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">package cn.john.cal;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @ClassName: Cal</span><br><span class="line"> * </span><br><span class="line"> * @Description:</span><br><span class="line"> *               &lt;p&gt;</span><br><span class="line"> *               基于后缀表达式的简易计算器，目前支持个位数加、减、乘、除、模和括号六种运算。</span><br><span class="line"> *               &lt;p&gt;</span><br><span class="line"> *               中缀表达式-&gt;后缀表达式 操作符入栈</span><br><span class="line"> *               &lt;p&gt;</span><br><span class="line"> *               后缀表达式-&gt;计算值 操作数入栈</span><br><span class="line"> * </span><br><span class="line"> * @author: John</span><br><span class="line"> * </span><br><span class="line"> * @date: 2017年5月9日 下午7:55:58</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class Cal &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	</span><br><span class="line">	 * @Title: toPostFix</span><br><span class="line">	</span><br><span class="line">	 * @Description: 将中缀表达式转换为后缀表达式</span><br><span class="line">	</span><br><span class="line">	 * @param infix</span><br><span class="line">	 * @return</span><br><span class="line">	</span><br><span class="line">	 * @return: String</span><br><span class="line">	</span><br><span class="line">	 */</span><br><span class="line">	public String toPostFix(String infix) &#123;</span><br><span class="line">		// 算式字符数组</span><br><span class="line">		char[] ch = infix.trim().toCharArray();</span><br><span class="line">		LinkedList&lt;OperatorsEnum&gt; stack = new LinkedList&lt;OperatorsEnum&gt;();</span><br><span class="line">		StringBuilder sb = new StringBuilder();</span><br><span class="line"></span><br><span class="line">		OperatorsEnum op = null;</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; ch.length; i++) &#123;</span><br><span class="line">			// 对每个算式字符，检查它是不是操作符</span><br><span class="line">			if ((op = isOperator(ch[i])) == null) &#123;</span><br><span class="line">				sb.append(ch[i]);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				// 右括号</span><br><span class="line">				// 持续弹出栈顶元素直到遇到左括号，但是不输出左括号</span><br><span class="line">				if (op.equals(OperatorsEnum.RIGHT_BRACKET)) &#123;</span><br><span class="line">					// 如果不是左括号，持续弹出并输出</span><br><span class="line">					while (!stack.peek().equals(OperatorsEnum.LEFT_BRACKET)) &#123;</span><br><span class="line">						sb.append(stack.pop());</span><br><span class="line">					&#125;</span><br><span class="line">					// 此时栈顶元素为左括号，直接弹出，不输出</span><br><span class="line">					stack.pop();</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					// 非右括号</span><br><span class="line">					// 1、弹出并输出所有高优先级或者同等优先级，直到遇到低优先级或者左括号为止</span><br><span class="line">					// 上面的弹出语句有可能将栈弹空，检查stack的size避免NPE</span><br><span class="line">					while (stack.size() &gt; 0 &amp;&amp; stack.peek().prior &gt;= op.prior</span><br><span class="line">							&amp;&amp; !stack.peek().equals(OperatorsEnum.LEFT_BRACKET)) &#123;</span><br><span class="line">						sb.append(stack.pop());</span><br><span class="line">					&#125;</span><br><span class="line">					// 2、将当前操作符入栈</span><br><span class="line">					stack.push(op);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 弹出所有栈中剩余操作符</span><br><span class="line">		while (stack.size() &gt; 0) &#123;</span><br><span class="line">			sb.append(stack.pop());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	</span><br><span class="line">	 * @Title: calc</span><br><span class="line">	</span><br><span class="line">	 * @Description: 计算后缀表达式的值</span><br><span class="line">	</span><br><span class="line">	 * @param postfix</span><br><span class="line">	 * @return</span><br><span class="line">	</span><br><span class="line">	 * @return: double</span><br><span class="line">	</span><br><span class="line">	 */</span><br><span class="line">	public double calc(String postfix) &#123;</span><br><span class="line">		char[] ch = postfix.toCharArray();</span><br><span class="line">		LinkedList&lt;Double&gt; stack = new LinkedList&lt;Double&gt;();</span><br><span class="line">		OperatorsEnum op = null;</span><br><span class="line">		for (int i = 0; i &lt; ch.length; i++) &#123;</span><br><span class="line">			if ((op = isOperator(ch[i])) == null) &#123;</span><br><span class="line">				// 不是操作符，将当前数值入栈</span><br><span class="line">				stack.push(Double.parseDouble(String.valueOf(ch[i])));</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				// 是操作符，进行计算</span><br><span class="line">				double b = stack.pop();</span><br><span class="line">				double a = stack.pop();</span><br><span class="line">				switch (op) &#123;</span><br><span class="line">				case PLUS:</span><br><span class="line">					stack.push(a + b);</span><br><span class="line">					break;</span><br><span class="line">				case MINUS:</span><br><span class="line">					stack.push(a - b);</span><br><span class="line">					break;</span><br><span class="line">				case MULTIPLY:</span><br><span class="line">					stack.push(a * b);</span><br><span class="line">					break;</span><br><span class="line">				case DIVIDE:</span><br><span class="line">					stack.push(a / b);</span><br><span class="line">					break;</span><br><span class="line">				case MODULAR:</span><br><span class="line">					stack.push(a % b);</span><br><span class="line">					break;</span><br><span class="line">				default:</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return stack.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	</span><br><span class="line">	 * @Title: isOperator</span><br><span class="line">	</span><br><span class="line">	 * @Description: 判断字符是否为操作符</span><br><span class="line">	</span><br><span class="line">	 * @param ch</span><br><span class="line">	 * @return</span><br><span class="line">	</span><br><span class="line">	 * @return: OperatorsEnum</span><br><span class="line">	</span><br><span class="line">	 */</span><br><span class="line">	private OperatorsEnum isOperator(char ch) &#123;</span><br><span class="line">		for (OperatorsEnum op : OperatorsEnum.values()) &#123;</span><br><span class="line">			if (ch == op.operator) &#123;</span><br><span class="line">				return op;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	// test</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	</span><br><span class="line">	 * @Title: readEquation</span><br><span class="line">	</span><br><span class="line">	 * @Description: 终端输入算式</span><br><span class="line">	</span><br><span class="line">	 * @return</span><br><span class="line">	</span><br><span class="line">	 * @return: String</span><br><span class="line">	</span><br><span class="line">	 */</span><br><span class="line">	public String readEquation() &#123;</span><br><span class="line">		Scanner sc = new Scanner(System.in);</span><br><span class="line">		String equation = sc.nextLine();</span><br><span class="line">		sc.close();</span><br><span class="line">		return equation;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Cal c = new Cal();</span><br><span class="line">		System.out.println(&quot;Please input an equation,press ENTER to submit!&quot;);</span><br><span class="line">		String infix = c.readEquation();</span><br><span class="line">		String s = c.toPostFix(infix);</span><br><span class="line">		System.out.println(&quot;postfix: &quot; + s);</span><br><span class="line">		System.out.println(&quot;Result: &quot;+infix + &quot;=&quot; + c.calc(s));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.7.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>




  

  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  




  





  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
